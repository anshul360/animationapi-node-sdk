/**
 * AnimationAPI
 * Scale your video production with AnimationAPI
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: anshulkumar@animationapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import type { RequestArgs } from './base';
import { BaseAPI } from './base';
/**
 *
 * @export
 * @interface AuthenticationErrorResponse
 */
export interface AuthenticationErrorResponse {
    /**
     *
     * @type {AuthenticationErrorResponseAllOfError}
     * @memberof AuthenticationErrorResponse
     */
    'error': AuthenticationErrorResponseAllOfError;
}
/**
 *
 * @export
 * @interface AuthenticationErrorResponseAllOfError
 */
export interface AuthenticationErrorResponseAllOfError {
    /**
     *
     * @type {string}
     * @memberof AuthenticationErrorResponseAllOfError
     */
    'code'?: AuthenticationErrorResponseAllOfErrorCodeEnum;
    /**
     *
     * @type {string}
     * @memberof AuthenticationErrorResponseAllOfError
     */
    'message'?: string;
}
export declare const AuthenticationErrorResponseAllOfErrorCodeEnum: {
    readonly AuthenticationRequired: "AUTHENTICATION_REQUIRED";
    readonly InvalidToken: "INVALID_TOKEN";
    readonly TokenExpired: "TOKEN_EXPIRED";
};
export type AuthenticationErrorResponseAllOfErrorCodeEnum = typeof AuthenticationErrorResponseAllOfErrorCodeEnum[keyof typeof AuthenticationErrorResponseAllOfErrorCodeEnum];
/**
 *
 * @export
 * @interface AuthorizationErrorResponse
 */
export interface AuthorizationErrorResponse {
    /**
     *
     * @type {AuthorizationErrorResponseAllOfError}
     * @memberof AuthorizationErrorResponse
     */
    'error': AuthorizationErrorResponseAllOfError;
}
/**
 *
 * @export
 * @interface AuthorizationErrorResponseAllOfError
 */
export interface AuthorizationErrorResponseAllOfError {
    /**
     *
     * @type {string}
     * @memberof AuthorizationErrorResponseAllOfError
     */
    'code'?: AuthorizationErrorResponseAllOfErrorCodeEnum;
    /**
     *
     * @type {any}
     * @memberof AuthorizationErrorResponseAllOfError
     */
    'message'?: any;
}
export declare const AuthorizationErrorResponseAllOfErrorCodeEnum: {
    readonly AccessDenied: "ACCESS_DENIED";
    readonly InsufficientPermissions: "INSUFFICIENT_PERMISSIONS";
    readonly ResourceForbidden: "RESOURCE_FORBIDDEN";
};
export type AuthorizationErrorResponseAllOfErrorCodeEnum = typeof AuthorizationErrorResponseAllOfErrorCodeEnum[keyof typeof AuthorizationErrorResponseAllOfErrorCodeEnum];
/**
 *
 * @export
 * @interface CreateVideosRequest
 */
export interface CreateVideosRequest {
    [key: string]: any;
    /**
     * The unique id of the Template. Can be copied from the project detail page.
     * @type {string}
     * @memberof CreateVideosRequest
     */
    'template_id': string;
    /**
     * The version of the Template. Can be obtained from the template\'s version view.
     * @type {number}
     * @memberof CreateVideosRequest
     */
    'version'?: number;
    /**
     * The format of the output video.  *Note: Frame rate for `gif` output is 12, For `mp4` and `webm` see `fps` property.*
     * @type {string}
     * @memberof CreateVideosRequest
     */
    'format': CreateVideosRequestFormatEnum;
    /**
     * Sets the output video frame rate if selected `format` is `mp4` or `webm`.
     * @type {number}
     * @memberof CreateVideosRequest
     */
    'fps'?: CreateVideosRequestFpsEnum;
    /**
     * The modifications needed on pages and the corresponding layers.
     * @type {Array<Page>}
     * @memberof CreateVideosRequest
     */
    'pages'?: Array<Page>;
    /**
     * The source url for the audio fo the output video.
     * @type {string}
     * @memberof CreateVideosRequest
     */
    'audio_url'?: string;
    /**
     * Any metadata that you need to store e.g. ID of a record in your DB.
     * @type {string}
     * @memberof CreateVideosRequest
     */
    'metadata'?: string;
}
export declare const CreateVideosRequestFormatEnum: {
    readonly Mp4: "mp4";
    readonly Webm: "webm";
    readonly Gif: "gif";
};
export type CreateVideosRequestFormatEnum = typeof CreateVideosRequestFormatEnum[keyof typeof CreateVideosRequestFormatEnum];
export declare const CreateVideosRequestFpsEnum: {
    readonly NUMBER_24: 24;
    readonly NUMBER_30: 30;
};
export type CreateVideosRequestFpsEnum = typeof CreateVideosRequestFpsEnum[keyof typeof CreateVideosRequestFpsEnum];
/**
 *
 * @export
 * @interface CreateWebhookEndpointRequest
 */
export interface CreateWebhookEndpointRequest {
    /**
     * The URL to send webhook notifications to
     * @type {string}
     * @memberof CreateWebhookEndpointRequest
     */
    'url': string;
    /**
     * List of events to subscribe to: `\"video.started\"`, `\"video.finished\"`, `\"video.failed\"`
     * @type {Array<string>}
     * @memberof CreateWebhookEndpointRequest
     */
    'events': Array<CreateWebhookEndpointRequestEventsEnum>;
    /**
     * Whether the webhook is enabled
     * @type {boolean}
     * @memberof CreateWebhookEndpointRequest
     */
    'enabled'?: boolean;
}
export declare const CreateWebhookEndpointRequestEventsEnum: {
    readonly VideoStarted: "video.started";
    readonly VideoFinished: "video.finished";
    readonly VideoFailed: "video.failed";
};
export type CreateWebhookEndpointRequestEventsEnum = typeof CreateWebhookEndpointRequestEventsEnum[keyof typeof CreateWebhookEndpointRequestEventsEnum];
/**
 *
 * @export
 * @interface GeneratedAssets
 */
export interface GeneratedAssets {
    /**
     * The rendered video url.
     * @type {string}
     * @memberof GeneratedAssets
     */
    'video_url'?: string;
    /**
     * Video creation timestamp.
     * @type {string}
     * @memberof GeneratedAssets
     */
    'created_date'?: string;
}
/**
 *
 * @export
 * @interface Layer
 */
export interface Layer {
    [key: string]: any;
    /**
     * Name of the layer. This can be obtained from Layers section from the editor.
     * @type {string}
     * @memberof Layer
     */
    'name': string;
    /**
     * Sets the text to render on the layer.   ***Layer(s): Text, Machine code***
     * @type {string}
     * @memberof Layer
     */
    'text'?: string;
    /**
     * Refers to the boldness or thickness of the characters.  ***Layer(s): Text***
     * @type {number}
     * @memberof Layer
     */
    'weight'?: LayerWeightEnum;
    /**
     * The vertical distance between baselines of adjacent lines of text.  ***Layer(s): Text***
     * @type {number}
     * @memberof Layer
     */
    'line_height'?: number;
    /**
     * Refers to the adjustment of space between characters.  ***Layer(s): Text***
     * @type {number}
     * @memberof Layer
     */
    'tracking'?: number;
    /**
     * If set to `true`, the font size will be adjusted to fit the entire text inside the layer bounds.  ***Layer(s): Text***
     * @type {boolean}
     * @memberof Layer
     */
    'fit_text'?: boolean;
    /**
     * The size of the font. This will take effect if `fit_text` property is set to false.  ***Layer(s): Text, Chart***
     * @type {number}
     * @memberof Layer
     */
    'font_size'?: number;
    /**
     * Sets the horizontal alignment of the text inside layer bounds.  ***Layer(s): Text***
     * @type {string}
     * @memberof Layer
     */
    'align'?: LayerAlignEnum;
    /**
     * Styles the text with a italic face.  ***Layer(s): Text***
     * @type {boolean}
     * @memberof Layer
     */
    'italic'?: boolean;
    /**
     * If set to `true`, each line of text has a decorative line going through its middle.  ***Layer(s): Text***
     * @type {boolean}
     * @memberof Layer
     */
    'line_through'?: boolean;
    /**
     * If set to `true`, each line of text has a decorative line beneath it.  ***Layer(s): Text***
     * @type {boolean}
     * @memberof Layer
     */
    'underline'?: boolean;
    /**
     * If set to `true`, each line of text has a decorative line above it.  ***Layer(s): Text***
     * @type {boolean}
     * @memberof Layer
     */
    'overline'?: boolean;
    /**
     * Sets the color of the text on Text layer.  ***Layer(s): Text, Chart***
     * @type {string}
     * @memberof Layer
     */
    'text_color'?: string;
    /**
     * The text outline color.  ***Layer(s): Text***
     * @type {string}
     * @memberof Layer
     */
    'outline_color'?: string;
    /**
     * The width of the text outline.  ***Layer(s): Text***
     * @type {string}
     * @memberof Layer
     */
    'outline_width'?: LayerOutlineWidthEnum;
    /**
     * Adds shadows to text. It accepts a comma-separated list of shadows to be applied to the text. [Click here](https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow) for more detail.  ***Layer(s): Text***
     * @type {string}
     * @memberof Layer
     */
    'text_shadow'?: string;
    /**
     * The source image/video url that will be rendered on layer.  ***Layer(s): Image, Video***
     * @type {string}
     * @memberof Layer
     */
    'source_url'?: string;
    /**
     * Specifies the alignment of the image within the layer bounds. The value defines both the horizontal (left, center, right) and vertical (top, center, bottom) anchor points for positioning the image.  ***Layer(s): Image***
     * @type {string}
     * @memberof Layer
     */
    'position'?: LayerPositionEnum;
    /**
     * Controls how the image is displayed within layer bounds.  ***Layer(s): Image***
     * @type {string}
     * @memberof Layer
     */
    'image_size'?: LayerImageSizeEnum;
    /**
     * Flip the image vertically/horizontally/both.  ***Layer(s): Image***
     * @type {string}
     * @memberof Layer
     */
    'flip'?: LayerFlipEnum;
    /**
     * Applies selected graphical effect to the image.  ***Layer(s): Image***
     * @type {string}
     * @memberof Layer
     */
    'effect'?: LayerEffectEnum;
    /**
     * Sets the width of the layer\'s border.  ***Layer(s): Image, Machine code***
     * @type {number}
     * @memberof Layer
     */
    'border_width'?: number;
    /**
     * Rounds the corners of the layer\'s outer border edge.   ***Layer(s): Image, Machine code***
     * @type {number}
     * @memberof Layer
     */
    'border_radius'?: number;
    /**
     * Sets the color of the layer\'s border.  ***Layer(s): Image, Machine code***
     * @type {string}
     * @memberof Layer
     */
    'border_color'?: string;
    /**
     * Adds shadow effects around the layer. You can set multiple effects separated by commas. [Click here](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow) for more detail.  ***Layer(s): Image***
     * @type {string}
     * @memberof Layer
     */
    'image_shadow'?: string;
    /**
     * Controls if the video\'s audio track will be mixed in the generated output or not.  ***Layer(s): Video***
     * @type {boolean}
     * @memberof Layer
     */
    'mute'?: boolean;
    /**
     * Controls whether the video will loop if the page\'s duration is greater than video\'s playtime.  ***Layer(s): Video***
     * @type {boolean}
     * @memberof Layer
     */
    'loop'?: boolean;
    /**
     * Sets the fill color of the shape, bar color on bar chart, line color on line chart, and partition color on pie chart.  ***Layer(s): Shape, Chart***
     * @type {string}
     * @memberof Layer
     */
    'fill_color'?: string;
    /**
     * Sets the stroke color of the shape.  ***Layer(s): Shape***
     * @type {string}
     * @memberof Layer
     */
    'stroke_color'?: string;
    /**
     * Sets the width of the stroke around the shape.  ***Layer(s): Shape***
     * @type {number}
     * @memberof Layer
     */
    'stroke_width'?: number;
    /**
     * The shape to be used at the corners of stroke.  ***Layer(s): Shape***
     * @type {string}
     * @memberof Layer
     */
    'stroke_corner'?: LayerStrokeCornerEnum;
    /**
     * Controls if the stoke around shape is dashed and in what proportion. 3:1 means 3 part stroke for 1 part space.  ***Layer(s): Shape***
     * @type {string}
     * @memberof Layer
     */
    'stroke_style'?: LayerStrokeStyleEnum;
    /**
     * Adds shadow effects around the layer. You can set multiple effects separated by commas. [Click here](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow) for more detail.  ***Layer(s): Shape***
     * @type {string}
     * @memberof Layer
     */
    'shape_shadow'?: string;
    /**
     * Sets the rating. The float values will rounded of to the nearest 0.5 eg: 1.2 => 1, 1.3 => 1.5.  ***Layer(s): Rating***
     * @type {number}
     * @memberof Layer
     */
    'rating'?: number;
    /**
     * Sets the active color of the rating.  ***Layer(s): Rating***
     * @type {string}
     * @memberof Layer
     */
    'active_fill_color'?: string;
    /**
     * Sets the inactive color of the rating.  ***Layer(s): Rating***
     * @type {string}
     * @memberof Layer
     */
    'inactive_fill_color'?: string;
    /**
     * Sets the fill color of the bar/QR code.  ***Layer(s): Machine code***
     * @type {string}
     * @memberof Layer
     */
    'foreground_color'?: string;
    /**
     * Sets the background color of the layer.  ***Layer(s): Machine code***
     * @type {string}
     * @memberof Layer
     */
    'background_color'?: string;
    /**
     * The data that will be used to generate the charts  ***Layer(s): Chart***
     * @type {Array<LayerChartDataInner>}
     * @memberof Layer
     */
    'chart_data'?: Array<LayerChartDataInner>;
    /**
     * Sets the color of: - The axes of bar/line chart. - The border of partion of pie chart.  ***Layer(s): Chart***
     * @type {string}
     * @memberof Layer
     */
    'axes_color'?: string;
}
export declare const LayerWeightEnum: {
    readonly NUMBER_100: 100;
    readonly NUMBER_200: 200;
    readonly NUMBER_300: 300;
    readonly NUMBER_400: 400;
    readonly NUMBER_500: 500;
    readonly NUMBER_600: 600;
    readonly NUMBER_700: 700;
    readonly NUMBER_800: 800;
    readonly NUMBER_900: 900;
};
export type LayerWeightEnum = typeof LayerWeightEnum[keyof typeof LayerWeightEnum];
export declare const LayerAlignEnum: {
    readonly Left: "left";
    readonly Center: "center";
    readonly Right: "right";
};
export type LayerAlignEnum = typeof LayerAlignEnum[keyof typeof LayerAlignEnum];
export declare const LayerOutlineWidthEnum: {
    readonly None: "none";
    readonly Thin: "thin";
    readonly Medium: "medium";
    readonly Thick: "thick";
};
export type LayerOutlineWidthEnum = typeof LayerOutlineWidthEnum[keyof typeof LayerOutlineWidthEnum];
export declare const LayerPositionEnum: {
    readonly LeftTop: "left top";
    readonly LeftBottom: "left bottom";
    readonly LeftCenter: "left center";
    readonly RightTop: "right top";
    readonly RightBottom: "right bottom";
    readonly RightCenter: "right center";
    readonly CenterTop: "center top";
    readonly CenterBottom: "center bottom";
    readonly CenterCenter: "center center";
};
export type LayerPositionEnum = typeof LayerPositionEnum[keyof typeof LayerPositionEnum];
export declare const LayerImageSizeEnum: {
    readonly Auto: "auto";
    readonly Cover: "cover";
    readonly Contain: "contain";
    readonly ContainRepeat: "contain repeat";
};
export type LayerImageSizeEnum = typeof LayerImageSizeEnum[keyof typeof LayerImageSizeEnum];
export declare const LayerFlipEnum: {
    readonly Vertical: "vertical";
    readonly Horizontal: "horizontal";
    readonly Both: "both";
    readonly Original: "original";
};
export type LayerFlipEnum = typeof LayerFlipEnum[keyof typeof LayerFlipEnum];
export declare const LayerEffectEnum: {
    readonly Grayscale1: "grayscale 1";
    readonly Grayscale2: "grayscale 2";
    readonly Grayscale3: "grayscale 3";
    readonly Sepia1: "sepia 1";
    readonly Sepia2: "sepia 2";
    readonly Sepia3: "sepia 3";
    readonly Blur1: "blur 1";
    readonly Blur2: "blur 2";
    readonly Blur3: "blur 3";
    readonly Invert1: "invert 1";
    readonly Invert2: "invert 2";
    readonly Invert3: "invert 3";
    readonly Vintage1: "vintage 1";
    readonly Vintage2: "vintage 2";
    readonly Vintage3: "vintage 3";
    readonly Pixelate1: "pixelate 1";
    readonly Pixelate2: "pixelate 2";
    readonly Pixelate3: "pixelate 3";
    readonly Noise: "noise";
    readonly Squiggly: "squiggly";
    readonly GrayscaleBlur: "grayscale blur";
    readonly GrayscalePixelate: "grayscale pixelate";
    readonly SepiaBlur: "sepia blur";
    readonly SepiaPixelate: "sepia pixelate";
    readonly VintageBlur: "vintage blur";
    readonly VintagePixelate: "vintage pixelate";
};
export type LayerEffectEnum = typeof LayerEffectEnum[keyof typeof LayerEffectEnum];
export declare const LayerStrokeCornerEnum: {
    readonly Round: "round";
    readonly Sharp: "sharp";
};
export type LayerStrokeCornerEnum = typeof LayerStrokeCornerEnum[keyof typeof LayerStrokeCornerEnum];
export declare const LayerStrokeStyleEnum: {
    readonly None: "none";
    readonly _11: "1:1";
    readonly _31: "3:1";
    readonly _61: "6:1";
};
export type LayerStrokeStyleEnum = typeof LayerStrokeStyleEnum[keyof typeof LayerStrokeStyleEnum];
/**
 *
 * @export
 * @interface LayerChartDataInner
 */
export interface LayerChartDataInner {
    /**
     * This is label for:  - The X axis on bar/line chart. - The partition on pie chart.
     * @type {string}
     * @memberof LayerChartDataInner
     */
    'label': string;
    /**
     * The value associated to the name.
     * @type {number}
     * @memberof LayerChartDataInner
     */
    'value': number;
}
/**
 *
 * @export
 * @interface ListAllTemplates200Response
 */
export interface ListAllTemplates200Response {
    /**
     *
     * @type {Array<ListAllTemplates200ResponseDataInner>}
     * @memberof ListAllTemplates200Response
     */
    'data'?: Array<ListAllTemplates200ResponseDataInner>;
    /**
     *
     * @type {Pagination}
     * @memberof ListAllTemplates200Response
     */
    'pagination'?: Pagination;
}
/**
 *
 * @export
 * @interface ListAllTemplates200ResponseDataInner
 */
export interface ListAllTemplates200ResponseDataInner {
    /**
     * The unique id of the template\'s
     * @type {string}
     * @memberof ListAllTemplates200ResponseDataInner
     */
    'id'?: string;
    /**
     * Template name
     * @type {string}
     * @memberof ListAllTemplates200ResponseDataInner
     */
    'name'?: string;
    /**
     * The template creation date
     * @type {string}
     * @memberof ListAllTemplates200ResponseDataInner
     */
    'created_at'?: string;
    /**
     * Last updated date of template
     * @type {string}
     * @memberof ListAllTemplates200ResponseDataInner
     */
    'updated_at'?: string;
}
/**
 *
 * @export
 * @interface ListAllVideos200Response
 */
export interface ListAllVideos200Response {
    /**
     *
     * @type {Array<GeneratedAssets>}
     * @memberof ListAllVideos200Response
     */
    'data'?: Array<GeneratedAssets>;
    /**
     *
     * @type {Pagination}
     * @memberof ListAllVideos200Response
     */
    'pagination'?: Pagination;
}
/**
 *
 * @export
 * @interface ListWebhooks200Response
 */
export interface ListWebhooks200Response {
    /**
     *
     * @type {Array<WebhookEndpoint>}
     * @memberof ListWebhooks200Response
     */
    'data'?: Array<WebhookEndpoint>;
    /**
     *
     * @type {Pagination}
     * @memberof ListWebhooks200Response
     */
    'pagination'?: Pagination;
}
/**
 *
 * @export
 * @interface NotFoundErrorResponse
 */
export interface NotFoundErrorResponse {
    /**
     *
     * @type {NotFoundErrorResponseAllOfError}
     * @memberof NotFoundErrorResponse
     */
    'error': NotFoundErrorResponseAllOfError;
}
/**
 *
 * @export
 * @interface NotFoundErrorResponseAllOfError
 */
export interface NotFoundErrorResponseAllOfError {
    /**
     *
     * @type {string}
     * @memberof NotFoundErrorResponseAllOfError
     */
    'code'?: NotFoundErrorResponseAllOfErrorCodeEnum;
    /**
     *
     * @type {any}
     * @memberof NotFoundErrorResponseAllOfError
     */
    'message'?: any;
}
export declare const NotFoundErrorResponseAllOfErrorCodeEnum: {
    readonly ResourceNotFound: "RESOURCE_NOT_FOUND";
    readonly EndpointNotFound: "ENDPOINT_NOT_FOUND";
};
export type NotFoundErrorResponseAllOfErrorCodeEnum = typeof NotFoundErrorResponseAllOfErrorCodeEnum[keyof typeof NotFoundErrorResponseAllOfErrorCodeEnum];
/**
 *
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * The number of the page you want to make modifications to.
     * @type {number}
     * @memberof Page
     */
    'number': number;
    /**
     * Sets the page\'s background color. It accepts any format of color or gradient.  `#3730a3`, `oklch(0.3984 0.1773 277.37)`, `radial-gradient(#e66465, blue)` are all valid values.
     * @type {string}
     * @memberof Page
     */
    'background_color'?: string;
    /**
     * The source url of the audio that will play during the page animation in output video.
     * @type {string}
     * @memberof Page
     */
    'page_audio_url'?: string;
    /**
     * #### Text layer propertires - text - weight - line_height - tracking - fit_text - font_size - align - italic - line_through - underline - overline - text_color - outline_color - outline_width - text_shadow #### Image layer properties - source_url - position - image_size - flip - effect - border_width - border_radius - border_color - image_shadow #### Video layer properties - source_url - mute - loop #### Shape layer properties - fill_color - stroke_color - stroke_width - stroke_corner - stroke_style - shape_shadow #### Rating layer properties - rating - active_fill_color - inactive_fill_color #### Machine code layer properties - text - foreground_color - background_color - border_width - border_radius - border_color #### Chart layer properties - chart_data - font_size - text_color - fill_color - axes_color
     * @type {Array<Layer>}
     * @memberof Page
     */
    'layers'?: Array<Layer>;
}
/**
 *
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     *
     * @type {number}
     * @memberof Pagination
     */
    'limit': number;
    /**
     *
     * @type {number}
     * @memberof Pagination
     */
    'offset': number;
    /**
     *
     * @type {number}
     * @memberof Pagination
     */
    'total': number;
    /**
     *
     * @type {boolean}
     * @memberof Pagination
     */
    'has_more': boolean;
}
/**
 *
 * @export
 * @interface PaymentRequiredErrorResponse
 */
export interface PaymentRequiredErrorResponse {
    /**
     *
     * @type {PaymentRequiredErrorResponseAllOfError}
     * @memberof PaymentRequiredErrorResponse
     */
    'error': PaymentRequiredErrorResponseAllOfError;
}
/**
 *
 * @export
 * @interface PaymentRequiredErrorResponseAllOfError
 */
export interface PaymentRequiredErrorResponseAllOfError {
    /**
     *
     * @type {string}
     * @memberof PaymentRequiredErrorResponseAllOfError
     */
    'code'?: PaymentRequiredErrorResponseAllOfErrorCodeEnum;
    /**
     *
     * @type {any}
     * @memberof PaymentRequiredErrorResponseAllOfError
     */
    'message'?: any;
}
export declare const PaymentRequiredErrorResponseAllOfErrorCodeEnum: {
    readonly PaymentRequired: "PAYMENT_REQUIRED";
    readonly InsufficientCredits: "INSUFFICIENT_CREDITS";
    readonly SubscriptionExpired: "SUBSCRIPTION_EXPIRED";
};
export type PaymentRequiredErrorResponseAllOfErrorCodeEnum = typeof PaymentRequiredErrorResponseAllOfErrorCodeEnum[keyof typeof PaymentRequiredErrorResponseAllOfErrorCodeEnum];
/**
 *
 * @export
 * @interface RateLimitErrorResponse
 */
export interface RateLimitErrorResponse {
    /**
     *
     * @type {RateLimitErrorResponseAllOfError}
     * @memberof RateLimitErrorResponse
     */
    'error': RateLimitErrorResponseAllOfError;
}
/**
 *
 * @export
 * @interface RateLimitErrorResponseAllOfError
 */
export interface RateLimitErrorResponseAllOfError {
    /**
     *
     * @type {string}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'code'?: RateLimitErrorResponseAllOfErrorCodeEnum;
    /**
     *
     * @type {any}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'message'?: any;
    /**
     * Number of seconds to wait before retrying
     * @type {number}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'retry_after'?: number;
    /**
     * The rate limit ceiling for this request
     * @type {number}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'limit'?: number;
    /**
     * Number of requests remaining in current time window
     * @type {number}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'remaining'?: number;
    /**
     * Unix timestamp when the rate limit resets
     * @type {number}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'reset'?: number;
}
export declare const RateLimitErrorResponseAllOfErrorCodeEnum: {
    readonly RateLimitExceeded: "RATE_LIMIT_EXCEEDED";
    readonly TooManyRequests: "TOO_MANY_REQUESTS";
};
export type RateLimitErrorResponseAllOfErrorCodeEnum = typeof RateLimitErrorResponseAllOfErrorCodeEnum[keyof typeof RateLimitErrorResponseAllOfErrorCodeEnum];
/**
 *
 * @export
 * @interface ServerErrorResponse
 */
export interface ServerErrorResponse {
    /**
     *
     * @type {ServerErrorResponseAllOfError}
     * @memberof ServerErrorResponse
     */
    'error': ServerErrorResponseAllOfError;
}
/**
 *
 * @export
 * @interface ServerErrorResponseAllOfError
 */
export interface ServerErrorResponseAllOfError {
    /**
     *
     * @type {string}
     * @memberof ServerErrorResponseAllOfError
     */
    'code'?: ServerErrorResponseAllOfErrorCodeEnum;
    /**
     *
     * @type {any}
     * @memberof ServerErrorResponseAllOfError
     */
    'message'?: any;
}
export declare const ServerErrorResponseAllOfErrorCodeEnum: {
    readonly InternalServerError: "INTERNAL_SERVER_ERROR";
    readonly ProcessingError: "PROCESSING_ERROR";
    readonly DatabaseError: "DATABASE_ERROR";
};
export type ServerErrorResponseAllOfErrorCodeEnum = typeof ServerErrorResponseAllOfErrorCodeEnum[keyof typeof ServerErrorResponseAllOfErrorCodeEnum];
/**
 *
 * @export
 * @interface ServiceUnavailableErrorResponse
 */
export interface ServiceUnavailableErrorResponse {
    /**
     *
     * @type {ServiceUnavailableErrorResponseAllOfError}
     * @memberof ServiceUnavailableErrorResponse
     */
    'error': ServiceUnavailableErrorResponseAllOfError;
}
/**
 *
 * @export
 * @interface ServiceUnavailableErrorResponseAllOfError
 */
export interface ServiceUnavailableErrorResponseAllOfError {
    /**
     *
     * @type {string}
     * @memberof ServiceUnavailableErrorResponseAllOfError
     */
    'code'?: ServiceUnavailableErrorResponseAllOfErrorCodeEnum;
    /**
     *
     * @type {any}
     * @memberof ServiceUnavailableErrorResponseAllOfError
     */
    'message'?: any;
    /**
     * Number of seconds to wait before retrying
     * @type {number}
     * @memberof ServiceUnavailableErrorResponseAllOfError
     */
    'retry_after'?: number;
}
export declare const ServiceUnavailableErrorResponseAllOfErrorCodeEnum: {
    readonly ServiceUnavailable: "SERVICE_UNAVAILABLE";
    readonly MaintenanceMode: "MAINTENANCE_MODE";
    readonly Overloaded: "OVERLOADED";
};
export type ServiceUnavailableErrorResponseAllOfErrorCodeEnum = typeof ServiceUnavailableErrorResponseAllOfErrorCodeEnum[keyof typeof ServiceUnavailableErrorResponseAllOfErrorCodeEnum];
/**
 *
 * @export
 * @interface StandardErrorResponse
 */
export interface StandardErrorResponse {
    /**
     *
     * @type {StandardErrorResponseError}
     * @memberof StandardErrorResponse
     */
    'error': StandardErrorResponseError;
}
/**
 *
 * @export
 * @interface StandardErrorResponseError
 */
export interface StandardErrorResponseError {
    /**
     * Error code identifying the type of error
     * @type {string}
     * @memberof StandardErrorResponseError
     */
    'code': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof StandardErrorResponseError
     */
    'message': string;
    /**
     * Additional error details (optional)
     * @type {string}
     * @memberof StandardErrorResponseError
     */
    'details'?: string;
}
/**
 *
 * @export
 * @interface UpdateWebhookEndpointRequest
 */
export interface UpdateWebhookEndpointRequest {
    /**
     * The URL to send webhook notifications to
     * @type {string}
     * @memberof UpdateWebhookEndpointRequest
     */
    'url'?: string;
    /**
     * List of events to subscribe to: `\"video.started\"`, `\"video.finished\"`, `\"video.failed\"`
     * @type {Array<string>}
     * @memberof UpdateWebhookEndpointRequest
     */
    'events'?: Array<UpdateWebhookEndpointRequestEventsEnum>;
    /**
     * Whether the webhook is enabled
     * @type {boolean}
     * @memberof UpdateWebhookEndpointRequest
     */
    'enabled'?: boolean;
}
export declare const UpdateWebhookEndpointRequestEventsEnum: {
    readonly VideoStarted: "video.started";
    readonly VideoFinished: "video.finished";
    readonly VideoFailed: "video.failed";
};
export type UpdateWebhookEndpointRequestEventsEnum = typeof UpdateWebhookEndpointRequestEventsEnum[keyof typeof UpdateWebhookEndpointRequestEventsEnum];
/**
 *
 * @export
 * @interface ValidationErrorDetail
 */
export interface ValidationErrorDetail {
    /**
     * The field that failed validation
     * @type {string}
     * @memberof ValidationErrorDetail
     */
    'field': string;
    /**
     * Specific error code for the validation failure
     * @type {string}
     * @memberof ValidationErrorDetail
     */
    'code': ValidationErrorDetailCodeEnum;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ValidationErrorDetail
     */
    'message': string;
    /**
     *
     * @type {any}
     * @memberof ValidationErrorDetail
     */
    'value'?: any;
}
export declare const ValidationErrorDetailCodeEnum: {
    readonly RequiredField: "REQUIRED_FIELD";
    readonly InvalidValue: "INVALID_VALUE";
    readonly InvalidType: "INVALID_TYPE";
    readonly InvalidFormat: "INVALID_FORMAT";
    readonly ValueTooSmall: "VALUE_TOO_SMALL";
    readonly ValueTooLarge: "VALUE_TOO_LARGE";
    readonly ValidationError: "VALIDATION_ERROR";
};
export type ValidationErrorDetailCodeEnum = typeof ValidationErrorDetailCodeEnum[keyof typeof ValidationErrorDetailCodeEnum];
/**
 *
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
    /**
     *
     * @type {ValidationErrorResponseError}
     * @memberof ValidationErrorResponse
     */
    'error': ValidationErrorResponseError;
}
/**
 *
 * @export
 * @interface ValidationErrorResponseError
 */
export interface ValidationErrorResponseError {
    /**
     * Error code for validation failures
     * @type {string}
     * @memberof ValidationErrorResponseError
     */
    'code': ValidationErrorResponseErrorCodeEnum;
    /**
     * High-level error message
     * @type {string}
     * @memberof ValidationErrorResponseError
     */
    'message': string;
    /**
     * Detailed validation errors for each field
     * @type {Array<ValidationErrorDetail>}
     * @memberof ValidationErrorResponseError
     */
    'details'?: Array<ValidationErrorDetail>;
}
export declare const ValidationErrorResponseErrorCodeEnum: {
    readonly ValidationError: "VALIDATION_ERROR";
};
export type ValidationErrorResponseErrorCodeEnum = typeof ValidationErrorResponseErrorCodeEnum[keyof typeof ValidationErrorResponseErrorCodeEnum];
/**
 *
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * The status of the video generation request.
     * @type {string}
     * @memberof Video
     */
    'status'?: VideoStatusEnum;
    /**
     * Unique id for the video generation request.
     * @type {string}
     * @memberof Video
     */
    'id'?: string;
    /**
     * The url the video generation request.
     * @type {string}
     * @memberof Video
     */
    'self'?: string;
    /**
     * The rendered video url.  This populates when the video has the status `COMPLETED`.
     * @type {string}
     * @memberof Video
     */
    'video_url'?: string;
    /**
     * The metadata passed to the video generation initiation request.
     * @type {string}
     * @memberof Video
     */
    'metadata'?: string;
    /**
     * Video genration request creation timestamp.
     * @type {string}
     * @memberof Video
     */
    'created_at'?: string;
    /**
     * Last updated timestamp of video genration request.
     * @type {string}
     * @memberof Video
     */
    'updated_at'?: string;
}
export declare const VideoStatusEnum: {
    readonly Queued: "QUEUED";
    readonly Processing: "PROCESSING";
    readonly Completed: "COMPLETED";
    readonly Failed: "FAILED";
};
export type VideoStatusEnum = typeof VideoStatusEnum[keyof typeof VideoStatusEnum];
/**
 *
 * @export
 * @interface WebhookEndpoint
 */
export interface WebhookEndpoint {
    /**
     *
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'id': string;
    /**
     *
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'org_id': string;
    /**
     *
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'url': string;
    /**
     *
     * @type {Array<string>}
     * @memberof WebhookEndpoint
     */
    'events': Array<WebhookEndpointEventsEnum>;
    /**
     *
     * @type {boolean}
     * @memberof WebhookEndpoint
     */
    'enabled': boolean;
    /**
     *
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'updated_at': string;
}
export declare const WebhookEndpointEventsEnum: {
    readonly VideoStarted: "video.started";
    readonly VideoFinished: "video.finished";
    readonly VideoFailed: "video.failed";
};
export type WebhookEndpointEventsEnum = typeof WebhookEndpointEventsEnum[keyof typeof WebhookEndpointEventsEnum];
/**
 *
 * @export
 * @interface WebhookEndpointCreate
 */
export interface WebhookEndpointCreate {
    /**
     * Unique identifier of the webhook endpoint.
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'id': string;
    /**
     * Keep this secret safe and do not share it. You won\'t be able to retrieve it again.
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'secret': string;
    /**
     * Organization identifier associated to the webhook endpoint
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'org_id': string;
    /**
     *
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'url': string;
    /**
     *
     * @type {Array<string>}
     * @memberof WebhookEndpointCreate
     */
    'events': Array<WebhookEndpointCreateEventsEnum>;
    /**
     *
     * @type {boolean}
     * @memberof WebhookEndpointCreate
     */
    'enabled': boolean;
    /**
     *
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'created_at': string;
    /**
     *
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'updated_at': string;
}
export declare const WebhookEndpointCreateEventsEnum: {
    readonly VideoStarted: "video.started";
    readonly VideoFinished: "video.finished";
    readonly VideoFailed: "video.failed";
};
export type WebhookEndpointCreateEventsEnum = typeof WebhookEndpointCreateEventsEnum[keyof typeof WebhookEndpointCreateEventsEnum];
/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export declare const TemplatesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * List all template\'s
     * @param {string} [id] Maximum number of results to return.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllTemplates: (id?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * TemplatesApi - functional programming interface
 * @export
 */
export declare const TemplatesApiFp: (configuration?: Configuration) => {
    /**
     * List all template\'s
     * @param {string} [id] Maximum number of results to return.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllTemplates(id?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllTemplates200Response>>;
};
/**
 * TemplatesApi - factory interface
 * @export
 */
export declare const TemplatesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * List all template\'s
     * @param {string} [id] Maximum number of results to return.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllTemplates(id?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAllTemplates200Response>;
};
/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export declare class TemplatesApi extends BaseAPI {
    /**
     * List all template\'s
     * @param {string} [id] Maximum number of results to return.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    listAllTemplates(id?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListAllTemplates200Response, any>>;
}
/**
 * VideosApi - axios parameter creator
 * @export
 */
export declare const VideosApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Use this endpoint to create a new video. Check the parameters for details.
     * @summary Create New Video
     * @param {CreateVideosRequest} createVideosRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVideos: (createVideosRequest: CreateVideosRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Endpoint to check the status of the video generation request
     * @param {string} id Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVideoStatus: (id: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * List all completed past video generation.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllVideos: (limit?: number, offset?: number, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * VideosApi - functional programming interface
 * @export
 */
export declare const VideosApiFp: (configuration?: Configuration) => {
    /**
     * Use this endpoint to create a new video. Check the parameters for details.
     * @summary Create New Video
     * @param {CreateVideosRequest} createVideosRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVideos(createVideosRequest: CreateVideosRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>>;
    /**
     * Endpoint to check the status of the video generation request
     * @param {string} id Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVideoStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>>;
    /**
     * List all completed past video generation.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllVideos(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllVideos200Response>>;
};
/**
 * VideosApi - factory interface
 * @export
 */
export declare const VideosApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Use this endpoint to create a new video. Check the parameters for details.
     * @summary Create New Video
     * @param {CreateVideosRequest} createVideosRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createVideos(createVideosRequest: CreateVideosRequest, options?: RawAxiosRequestConfig): AxiosPromise<Video>;
    /**
     * Endpoint to check the status of the video generation request
     * @param {string} id Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVideoStatus(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Video>;
    /**
     * List all completed past video generation.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAllVideos(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAllVideos200Response>;
};
/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export declare class VideosApi extends BaseAPI {
    /**
     * Use this endpoint to create a new video. Check the parameters for details.
     * @summary Create New Video
     * @param {CreateVideosRequest} createVideosRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    createVideos(createVideosRequest: CreateVideosRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Video, any>>;
    /**
     * Endpoint to check the status of the video generation request
     * @param {string} id Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    getVideoStatus(id: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<Video, any>>;
    /**
     * List all completed past video generation.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    listAllVideos(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListAllVideos200Response, any>>;
}
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export declare const WebhooksApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new webhook endpoint for the authenticated organization
     * @summary Create webhook
     * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook: (createWebhookEndpointRequest: CreateWebhookEndpointRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete a webhook endpoint by ID
     * @summary Delete webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook: (webhookId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve a specific webhook endpoint by ID
     * @summary Get webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook: (webhookId: string, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieve all webhook endpoints for the authenticated organization
     * @summary List webhooks
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Number of results to skip
     * @param {boolean} [enabled] Filter by enabled status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks: (limit?: number, offset?: number, enabled?: boolean, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update an existing webhook endpoint
     * @summary Update webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook: (webhookId: string, updateWebhookEndpointRequest: UpdateWebhookEndpointRequest, options?: RawAxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * WebhooksApi - functional programming interface
 * @export
 */
export declare const WebhooksApiFp: (configuration?: Configuration) => {
    /**
     * Create a new webhook endpoint for the authenticated organization
     * @summary Create webhook
     * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(createWebhookEndpointRequest: CreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpointCreate>>;
    /**
     * Delete a webhook endpoint by ID
     * @summary Delete webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieve a specific webhook endpoint by ID
     * @summary Get webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpoint>>;
    /**
     * Retrieve all webhook endpoints for the authenticated organization
     * @summary List webhooks
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Number of results to skip
     * @param {boolean} [enabled] Filter by enabled status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks(limit?: number, offset?: number, enabled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhooks200Response>>;
    /**
     * Update an existing webhook endpoint
     * @summary Update webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(webhookId: string, updateWebhookEndpointRequest: UpdateWebhookEndpointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpoint>>;
};
/**
 * WebhooksApi - factory interface
 * @export
 */
export declare const WebhooksApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new webhook endpoint for the authenticated organization
     * @summary Create webhook
     * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWebhook(createWebhookEndpointRequest: CreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEndpointCreate>;
    /**
     * Delete a webhook endpoint by ID
     * @summary Delete webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;
    /**
     * Retrieve a specific webhook endpoint by ID
     * @summary Get webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEndpoint>;
    /**
     * Retrieve all webhook endpoints for the authenticated organization
     * @summary List webhooks
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Number of results to skip
     * @param {boolean} [enabled] Filter by enabled status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWebhooks(limit?: number, offset?: number, enabled?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListWebhooks200Response>;
    /**
     * Update an existing webhook endpoint
     * @summary Update webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWebhook(webhookId: string, updateWebhookEndpointRequest: UpdateWebhookEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEndpoint>;
};
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export declare class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook endpoint for the authenticated organization
     * @summary Create webhook
     * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWebhook(createWebhookEndpointRequest: CreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<WebhookEndpointCreate, any>>;
    /**
     * Delete a webhook endpoint by ID
     * @summary Delete webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<void, any>>;
    /**
     * Retrieve a specific webhook endpoint by ID
     * @summary Get webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<WebhookEndpoint, any>>;
    /**
     * Retrieve all webhook endpoints for the authenticated organization
     * @summary List webhooks
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Number of results to skip
     * @param {boolean} [enabled] Filter by enabled status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listAllWebhooks(limit?: number, offset?: number, enabled?: boolean, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<ListWebhooks200Response, any>>;
    /**
     * Update an existing webhook endpoint
     * @summary Update webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    updateWebhook(webhookId: string, updateWebhookEndpointRequest: UpdateWebhookEndpointRequest, options?: RawAxiosRequestConfig): Promise<import("axios").AxiosResponse<WebhookEndpoint, any>>;
}
