'use strict';

var globalAxios = require('axios');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/* tslint:disable */
/* eslint-disable */
/**
 * AnimationAPI
 * Scale your video production with AnimationAPI
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: anshulkumar@animationapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const BASE_PATH = "https://api.animationapi.com/v1".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, axios = globalAxios) {
        var _a;
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = (_a = configuration.basePath) !== null && _a !== void 0 ? _a : basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
/**
 *
 * @export
 */
const operationServerMap = {};

/* tslint:disable */
/* eslint-disable */
/**
 * AnimationAPI
 * Scale your video production with AnimationAPI
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: anshulkumar@animationapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/**
 *
 * @export
 */
const DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
/**
 *
 * @export
 */
const setBearerAuthToObject = function (object, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
            const accessToken = typeof configuration.accessToken === 'function'
                ? yield configuration.accessToken()
                : yield configuration.accessToken;
            object["Authorization"] = "Bearer " + accessToken;
        }
    });
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (parameter == null)
        return;
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));
        }
        else {
            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));
        }
    }
    else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        }
        else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    return needsSerialization
        ? JSON.stringify(value !== undefined ? value : {})
        : (value || "");
};
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        var _a;
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: (axios.defaults.baseURL ? '' : (_a = configuration === null || configuration === void 0 ? void 0 : configuration.basePath) !== null && _a !== void 0 ? _a : basePath) + axiosArgs.url, validateStatus: () => true });
        return axios.request(axiosRequestArgs);
    };
};

/* tslint:disable */
/* eslint-disable */
/**
 * AnimationAPI
 * Scale your video production with AnimationAPI
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: anshulkumar@animationapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
const AuthenticationErrorResponseAllOfErrorCodeEnum = {
    AuthenticationRequired: 'AUTHENTICATION_REQUIRED',
    InvalidToken: 'INVALID_TOKEN',
    TokenExpired: 'TOKEN_EXPIRED'
};
const AuthorizationErrorResponseAllOfErrorCodeEnum = {
    AccessDenied: 'ACCESS_DENIED',
    InsufficientPermissions: 'INSUFFICIENT_PERMISSIONS',
    ResourceForbidden: 'RESOURCE_FORBIDDEN'
};
const CreateVideosRequestFormatEnum = {
    Mp4: 'mp4',
    Webm: 'webm',
    Gif: 'gif'
};
const CreateVideosRequestFpsEnum = {
    NUMBER_24: 24,
    NUMBER_30: 30
};
const CreateWebhookEndpointRequestEventsEnum = {
    VideoStarted: 'video.started',
    VideoFinished: 'video.finished',
    VideoFailed: 'video.failed'
};
const LayerWeightEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_600: 600,
    NUMBER_700: 700,
    NUMBER_800: 800,
    NUMBER_900: 900
};
const LayerAlignEnum = {
    Left: 'left',
    Center: 'center',
    Right: 'right'
};
const LayerOutlineWidthEnum = {
    None: 'none',
    Thin: 'thin',
    Medium: 'medium',
    Thick: 'thick'
};
const LayerPositionEnum = {
    LeftTop: 'left top',
    LeftBottom: 'left bottom',
    LeftCenter: 'left center',
    RightTop: 'right top',
    RightBottom: 'right bottom',
    RightCenter: 'right center',
    CenterTop: 'center top',
    CenterBottom: 'center bottom',
    CenterCenter: 'center center'
};
const LayerImageSizeEnum = {
    Auto: 'auto',
    Cover: 'cover',
    Contain: 'contain',
    ContainRepeat: 'contain repeat'
};
const LayerFlipEnum = {
    Vertical: 'vertical',
    Horizontal: 'horizontal',
    Both: 'both',
    Original: 'original'
};
const LayerEffectEnum = {
    Grayscale1: 'grayscale 1',
    Grayscale2: 'grayscale 2',
    Grayscale3: 'grayscale 3',
    Sepia1: 'sepia 1',
    Sepia2: 'sepia 2',
    Sepia3: 'sepia 3',
    Blur1: 'blur 1',
    Blur2: 'blur 2',
    Blur3: 'blur 3',
    Invert1: 'invert 1',
    Invert2: 'invert 2',
    Invert3: 'invert 3',
    Vintage1: 'vintage 1',
    Vintage2: 'vintage 2',
    Vintage3: 'vintage 3',
    Pixelate1: 'pixelate 1',
    Pixelate2: 'pixelate 2',
    Pixelate3: 'pixelate 3',
    Noise: 'noise',
    Squiggly: 'squiggly',
    GrayscaleBlur: 'grayscale blur',
    GrayscalePixelate: 'grayscale pixelate',
    SepiaBlur: 'sepia blur',
    SepiaPixelate: 'sepia pixelate',
    VintageBlur: 'vintage blur',
    VintagePixelate: 'vintage pixelate'
};
const LayerStrokeCornerEnum = {
    Round: 'round',
    Sharp: 'sharp'
};
const LayerStrokeStyleEnum = {
    None: 'none',
    _11: '1:1',
    _31: '3:1',
    _61: '6:1'
};
const NotFoundErrorResponseAllOfErrorCodeEnum = {
    ResourceNotFound: 'RESOURCE_NOT_FOUND',
    EndpointNotFound: 'ENDPOINT_NOT_FOUND'
};
const PaymentRequiredErrorResponseAllOfErrorCodeEnum = {
    PaymentRequired: 'PAYMENT_REQUIRED',
    InsufficientCredits: 'INSUFFICIENT_CREDITS',
    SubscriptionExpired: 'SUBSCRIPTION_EXPIRED'
};
const RateLimitErrorResponseAllOfErrorCodeEnum = {
    RateLimitExceeded: 'RATE_LIMIT_EXCEEDED',
    TooManyRequests: 'TOO_MANY_REQUESTS'
};
const ServerErrorResponseAllOfErrorCodeEnum = {
    InternalServerError: 'INTERNAL_SERVER_ERROR',
    ProcessingError: 'PROCESSING_ERROR',
    DatabaseError: 'DATABASE_ERROR'
};
const ServiceUnavailableErrorResponseAllOfErrorCodeEnum = {
    ServiceUnavailable: 'SERVICE_UNAVAILABLE',
    MaintenanceMode: 'MAINTENANCE_MODE',
    Overloaded: 'OVERLOADED'
};
const UpdateWebhookEndpointRequestEventsEnum = {
    VideoStarted: 'video.started',
    VideoFinished: 'video.finished',
    VideoFailed: 'video.failed'
};
const ValidationErrorDetailCodeEnum = {
    RequiredField: 'REQUIRED_FIELD',
    InvalidValue: 'INVALID_VALUE',
    InvalidType: 'INVALID_TYPE',
    InvalidFormat: 'INVALID_FORMAT',
    ValueTooSmall: 'VALUE_TOO_SMALL',
    ValueTooLarge: 'VALUE_TOO_LARGE',
    ValidationError: 'VALIDATION_ERROR'
};
const ValidationErrorResponseErrorCodeEnum = {
    ValidationError: 'VALIDATION_ERROR'
};
const VideoStatusEnum = {
    Queued: 'QUEUED',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
};
const WebhookEndpointEventsEnum = {
    VideoStarted: 'video.started',
    VideoFinished: 'video.finished',
    VideoFailed: 'video.failed'
};
const WebhookEndpointCreateEventsEnum = {
    VideoStarted: 'video.started',
    VideoFinished: 'video.finished',
    VideoFailed: 'video.failed'
};
/**
 * TemplatesApi - axios parameter creator
 * @export
 */
const TemplatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List all template\'s
         * @param {string} [id] Maximum number of results to return.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTemplates: (id_1, limit_1, offset_1, ...args_1) => __awaiter(this, [id_1, limit_1, offset_1, ...args_1], void 0, function* (id, limit, offset, options = {}) {
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TemplatesApi - functional programming interface
 * @export
 */
const TemplatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration);
    return {
        /**
         * List all template\'s
         * @param {string} [id] Maximum number of results to return.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTemplates(id, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAllTemplates(id, limit, offset, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['TemplatesApi.listAllTemplates']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * TemplatesApi - factory interface
 * @export
 */
const TemplatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TemplatesApiFp(configuration);
    return {
        /**
         * List all template\'s
         * @param {string} [id] Maximum number of results to return.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTemplates(id, limit, offset, options) {
            return localVarFp.listAllTemplates(id, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
class TemplatesApi extends BaseAPI {
    /**
     * List all template\'s
     * @param {string} [id] Maximum number of results to return.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    listAllTemplates(id, limit, offset, options) {
        return TemplatesApiFp(this.configuration).listAllTemplates(id, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * VideosApi - axios parameter creator
 * @export
 */
const VideosApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use this endpoint to create a new video. Check the parameters for details.
         * @summary Create New Video
         * @param {CreateVideosRequest} createVideosRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideos: (createVideosRequest_1, ...args_1) => __awaiter(this, [createVideosRequest_1, ...args_1], void 0, function* (createVideosRequest, options = {}) {
            // verify required parameter 'createVideosRequest' is not null or undefined
            assertParamExists('createVideos', 'createVideosRequest', createVideosRequest);
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createVideosRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Endpoint to check the status of the video generation request
         * @param {string} id Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStatus: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVideoStatus', 'id', id);
            const localVarPath = `/videos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all completed past video generation.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllVideos: (limit_1, offset_1, ...args_1) => __awaiter(this, [limit_1, offset_1, ...args_1], void 0, function* (limit, offset, options = {}) {
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VideosApi - functional programming interface
 * @export
 */
const VideosApiFp = function (configuration) {
    const localVarAxiosParamCreator = VideosApiAxiosParamCreator(configuration);
    return {
        /**
         * Use this endpoint to create a new video. Check the parameters for details.
         * @summary Create New Video
         * @param {CreateVideosRequest} createVideosRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideos(createVideosRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createVideos(createVideosRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['VideosApi.createVideos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Endpoint to check the status of the video generation request
         * @param {string} id Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStatus(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getVideoStatus(id, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['VideosApi.getVideoStatus']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List all completed past video generation.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllVideos(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listAllVideos(limit, offset, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['VideosApi.listAllVideos']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * VideosApi - factory interface
 * @export
 */
const VideosApiFactory = function (configuration, basePath, axios) {
    const localVarFp = VideosApiFp(configuration);
    return {
        /**
         * Use this endpoint to create a new video. Check the parameters for details.
         * @summary Create New Video
         * @param {CreateVideosRequest} createVideosRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideos(createVideosRequest, options) {
            return localVarFp.createVideos(createVideosRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint to check the status of the video generation request
         * @param {string} id Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStatus(id, options) {
            return localVarFp.getVideoStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all completed past video generation.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllVideos(limit, offset, options) {
            return localVarFp.listAllVideos(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
class VideosApi extends BaseAPI {
    /**
     * Use this endpoint to create a new video. Check the parameters for details.
     * @summary Create New Video
     * @param {CreateVideosRequest} createVideosRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    createVideos(createVideosRequest, options) {
        return VideosApiFp(this.configuration).createVideos(createVideosRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Endpoint to check the status of the video generation request
     * @param {string} id Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    getVideoStatus(id, options) {
        return VideosApiFp(this.configuration).getVideoStatus(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all completed past video generation.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    listAllVideos(limit, offset, options) {
        return VideosApiFp(this.configuration).listAllVideos(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * WebhooksApi - axios parameter creator
 * @export
 */
const WebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new webhook endpoint for the authenticated organization
         * @summary Create webhook
         * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: (createWebhookEndpointRequest_1, ...args_1) => __awaiter(this, [createWebhookEndpointRequest_1, ...args_1], void 0, function* (createWebhookEndpointRequest, options = {}) {
            // verify required parameter 'createWebhookEndpointRequest' is not null or undefined
            assertParamExists('createWebhook', 'createWebhookEndpointRequest', createWebhookEndpointRequest);
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookEndpointRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a webhook endpoint by ID
         * @summary Delete webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: (webhookId_1, ...args_1) => __awaiter(this, [webhookId_1, ...args_1], void 0, function* (webhookId, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a specific webhook endpoint by ID
         * @summary Get webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: (webhookId_1, ...args_1) => __awaiter(this, [webhookId_1, ...args_1], void 0, function* (webhookId, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhook', 'webhookId', webhookId);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve all webhook endpoints for the authenticated organization
         * @summary List webhooks
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Number of results to skip
         * @param {boolean} [enabled] Filter by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: (limit_1, offset_1, enabled_1, ...args_1) => __awaiter(this, [limit_1, offset_1, enabled_1, ...args_1], void 0, function* (limit, offset, enabled, options = {}) {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update an existing webhook endpoint
         * @summary Update webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: (webhookId_1, updateWebhookEndpointRequest_1, ...args_1) => __awaiter(this, [webhookId_1, updateWebhookEndpointRequest_1, ...args_1], void 0, function* (webhookId, updateWebhookEndpointRequest, options = {}) {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId);
            // verify required parameter 'updateWebhookEndpointRequest' is not null or undefined
            assertParamExists('updateWebhook', 'updateWebhookEndpointRequest', updateWebhookEndpointRequest);
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookEndpointRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * WebhooksApi - functional programming interface
 * @export
 */
const WebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new webhook endpoint for the authenticated organization
         * @summary Create webhook
         * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookEndpointRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createWebhook(createWebhookEndpointRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WebhooksApi.createWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Delete a webhook endpoint by ID
         * @summary Delete webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteWebhook(webhookId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WebhooksApi.deleteWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve a specific webhook endpoint by ID
         * @summary Get webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getWebhook(webhookId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WebhooksApi.getWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve all webhook endpoints for the authenticated organization
         * @summary List webhooks
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Number of results to skip
         * @param {boolean} [enabled] Filter by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(limit, offset, enabled, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listWebhooks(limit, offset, enabled, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WebhooksApi.listWebhooks']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Update an existing webhook endpoint
         * @summary Update webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, updateWebhookEndpointRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookEndpointRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = (_c = (_b = operationServerMap['WebhooksApi.updateWebhook']) === null || _b === void 0 ? void 0 : _b[localVarOperationServerIndex]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * WebhooksApi - factory interface
 * @export
 */
const WebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = WebhooksApiFp(configuration);
    return {
        /**
         * Create a new webhook endpoint for the authenticated organization
         * @summary Create webhook
         * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookEndpointRequest, options) {
            return localVarFp.createWebhook(createWebhookEndpointRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook endpoint by ID
         * @summary Delete webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId, options) {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific webhook endpoint by ID
         * @summary Get webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId, options) {
            return localVarFp.getWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all webhook endpoints for the authenticated organization
         * @summary List webhooks
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Number of results to skip
         * @param {boolean} [enabled] Filter by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(limit, offset, enabled, options) {
            return localVarFp.listWebhooks(limit, offset, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing webhook endpoint
         * @summary Update webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId, updateWebhookEndpointRequest, options) {
            return localVarFp.updateWebhook(webhookId, updateWebhookEndpointRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook endpoint for the authenticated organization
     * @summary Create webhook
     * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    createWebhook(createWebhookEndpointRequest, options) {
        return WebhooksApiFp(this.configuration).createWebhook(createWebhookEndpointRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a webhook endpoint by ID
     * @summary Delete webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    deleteWebhook(webhookId, options) {
        return WebhooksApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific webhook endpoint by ID
     * @summary Get webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    getWebhook(webhookId, options) {
        return WebhooksApiFp(this.configuration).getWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve all webhook endpoints for the authenticated organization
     * @summary List webhooks
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Number of results to skip
     * @param {boolean} [enabled] Filter by enabled status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    listAllWebhooks(limit, offset, enabled, options) {
        return WebhooksApiFp(this.configuration).listWebhooks(limit, offset, enabled, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing webhook endpoint
     * @summary Update webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    updateWebhook(webhookId, updateWebhookEndpointRequest, options) {
        return WebhooksApiFp(this.configuration).updateWebhook(webhookId, updateWebhookEndpointRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/* tslint:disable */
/* eslint-disable */
/**
 * AnimationAPI
 * Scale your video production with AnimationAPI
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: anshulkumar@animationapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
    constructor(param = {}) {
        var _a;
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.serverIndex = param.serverIndex;
        this.baseOptions = Object.assign(Object.assign({}, param.baseOptions), { headers: Object.assign({}, (_a = param.baseOptions) === null || _a === void 0 ? void 0 : _a.headers) });
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}

exports.AuthenticationErrorResponseAllOfErrorCodeEnum = AuthenticationErrorResponseAllOfErrorCodeEnum;
exports.AuthorizationErrorResponseAllOfErrorCodeEnum = AuthorizationErrorResponseAllOfErrorCodeEnum;
exports.Configuration = Configuration;
exports.CreateVideosRequestFormatEnum = CreateVideosRequestFormatEnum;
exports.CreateVideosRequestFpsEnum = CreateVideosRequestFpsEnum;
exports.CreateWebhookEndpointRequestEventsEnum = CreateWebhookEndpointRequestEventsEnum;
exports.LayerAlignEnum = LayerAlignEnum;
exports.LayerEffectEnum = LayerEffectEnum;
exports.LayerFlipEnum = LayerFlipEnum;
exports.LayerImageSizeEnum = LayerImageSizeEnum;
exports.LayerOutlineWidthEnum = LayerOutlineWidthEnum;
exports.LayerPositionEnum = LayerPositionEnum;
exports.LayerStrokeCornerEnum = LayerStrokeCornerEnum;
exports.LayerStrokeStyleEnum = LayerStrokeStyleEnum;
exports.LayerWeightEnum = LayerWeightEnum;
exports.NotFoundErrorResponseAllOfErrorCodeEnum = NotFoundErrorResponseAllOfErrorCodeEnum;
exports.PaymentRequiredErrorResponseAllOfErrorCodeEnum = PaymentRequiredErrorResponseAllOfErrorCodeEnum;
exports.RateLimitErrorResponseAllOfErrorCodeEnum = RateLimitErrorResponseAllOfErrorCodeEnum;
exports.ServerErrorResponseAllOfErrorCodeEnum = ServerErrorResponseAllOfErrorCodeEnum;
exports.ServiceUnavailableErrorResponseAllOfErrorCodeEnum = ServiceUnavailableErrorResponseAllOfErrorCodeEnum;
exports.TemplatesApi = TemplatesApi;
exports.TemplatesApiAxiosParamCreator = TemplatesApiAxiosParamCreator;
exports.TemplatesApiFactory = TemplatesApiFactory;
exports.TemplatesApiFp = TemplatesApiFp;
exports.UpdateWebhookEndpointRequestEventsEnum = UpdateWebhookEndpointRequestEventsEnum;
exports.ValidationErrorDetailCodeEnum = ValidationErrorDetailCodeEnum;
exports.ValidationErrorResponseErrorCodeEnum = ValidationErrorResponseErrorCodeEnum;
exports.VideoStatusEnum = VideoStatusEnum;
exports.VideosApi = VideosApi;
exports.VideosApiAxiosParamCreator = VideosApiAxiosParamCreator;
exports.VideosApiFactory = VideosApiFactory;
exports.VideosApiFp = VideosApiFp;
exports.WebhookEndpointCreateEventsEnum = WebhookEndpointCreateEventsEnum;
exports.WebhookEndpointEventsEnum = WebhookEndpointEventsEnum;
exports.WebhooksApi = WebhooksApi;
exports.WebhooksApiAxiosParamCreator = WebhooksApiAxiosParamCreator;
exports.WebhooksApiFactory = WebhooksApiFactory;
exports.WebhooksApiFp = WebhooksApiFp;
//# sourceMappingURL=sdk.cjs.js.map
