/* tslint:disable */
/* eslint-disable */
/**
 * AnimationAPI
 * Scale your video production with AnimationAPI
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: anshulkumar@animationapi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthenticationErrorResponse
 */
export interface AuthenticationErrorResponse {
    /**
     * 
     * @type {AuthenticationErrorResponseAllOfError}
     * @memberof AuthenticationErrorResponse
     */
    'error': AuthenticationErrorResponseAllOfError;
}
/**
 * 
 * @export
 * @interface AuthenticationErrorResponseAllOfError
 */
export interface AuthenticationErrorResponseAllOfError {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationErrorResponseAllOfError
     */
    'code'?: AuthenticationErrorResponseAllOfErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationErrorResponseAllOfError
     */
    'message'?: string;
}

export const AuthenticationErrorResponseAllOfErrorCodeEnum = {
    AuthenticationRequired: 'AUTHENTICATION_REQUIRED',
    InvalidToken: 'INVALID_TOKEN',
    TokenExpired: 'TOKEN_EXPIRED'
} as const;

export type AuthenticationErrorResponseAllOfErrorCodeEnum = typeof AuthenticationErrorResponseAllOfErrorCodeEnum[keyof typeof AuthenticationErrorResponseAllOfErrorCodeEnum];

/**
 * 
 * @export
 * @interface AuthorizationErrorResponse
 */
export interface AuthorizationErrorResponse {
    /**
     * 
     * @type {AuthorizationErrorResponseAllOfError}
     * @memberof AuthorizationErrorResponse
     */
    'error': AuthorizationErrorResponseAllOfError;
}
/**
 * 
 * @export
 * @interface AuthorizationErrorResponseAllOfError
 */
export interface AuthorizationErrorResponseAllOfError {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationErrorResponseAllOfError
     */
    'code'?: AuthorizationErrorResponseAllOfErrorCodeEnum;
    /**
     * 
     * @type {any}
     * @memberof AuthorizationErrorResponseAllOfError
     */
    'message'?: any;
}

export const AuthorizationErrorResponseAllOfErrorCodeEnum = {
    AccessDenied: 'ACCESS_DENIED',
    InsufficientPermissions: 'INSUFFICIENT_PERMISSIONS',
    ResourceForbidden: 'RESOURCE_FORBIDDEN'
} as const;

export type AuthorizationErrorResponseAllOfErrorCodeEnum = typeof AuthorizationErrorResponseAllOfErrorCodeEnum[keyof typeof AuthorizationErrorResponseAllOfErrorCodeEnum];

/**
 * 
 * @export
 * @interface CreateVideosRequest
 */
export interface CreateVideosRequest {
    [key: string]: any;

    /**
     * The unique id of the Template. Can be copied from the project detail page. 
     * @type {string}
     * @memberof CreateVideosRequest
     */
    'template_id': string;
    /**
     * The version of the Template. Can be obtained from the template\'s version view. 
     * @type {number}
     * @memberof CreateVideosRequest
     */
    'version'?: number;
    /**
     * The format of the output video.  *Note: Frame rate for `gif` output is 12, For `mp4` and `webm` see `fps` property.* 
     * @type {string}
     * @memberof CreateVideosRequest
     */
    'format': CreateVideosRequestFormatEnum;
    /**
     * Sets the output video frame rate if selected `format` is `mp4` or `webm`. 
     * @type {number}
     * @memberof CreateVideosRequest
     */
    'fps'?: CreateVideosRequestFpsEnum;
    /**
     * The modifications needed on pages and the corresponding layers.  
     * @type {Array<Page>}
     * @memberof CreateVideosRequest
     */
    'pages'?: Array<Page>;
    /**
     * The source url for the audio fo the output video. 
     * @type {string}
     * @memberof CreateVideosRequest
     */
    'audio_url'?: string;
    /**
     * Any metadata that you need to store e.g. ID of a record in your DB. 
     * @type {string}
     * @memberof CreateVideosRequest
     */
    'metadata'?: string;
}

export const CreateVideosRequestFormatEnum = {
    Mp4: 'mp4',
    Webm: 'webm',
    Gif: 'gif'
} as const;

export type CreateVideosRequestFormatEnum = typeof CreateVideosRequestFormatEnum[keyof typeof CreateVideosRequestFormatEnum];
export const CreateVideosRequestFpsEnum = {
    NUMBER_24: 24,
    NUMBER_30: 30
} as const;

export type CreateVideosRequestFpsEnum = typeof CreateVideosRequestFpsEnum[keyof typeof CreateVideosRequestFpsEnum];

/**
 * 
 * @export
 * @interface CreateWebhookEndpointRequest
 */
export interface CreateWebhookEndpointRequest {
    /**
     * The URL to send webhook notifications to
     * @type {string}
     * @memberof CreateWebhookEndpointRequest
     */
    'url': string;
    /**
     * List of events to subscribe to: `\"video.started\"`, `\"video.finished\"`, `\"video.failed\"` 
     * @type {Array<string>}
     * @memberof CreateWebhookEndpointRequest
     */
    'events': Array<CreateWebhookEndpointRequestEventsEnum>;
    /**
     * Whether the webhook is enabled
     * @type {boolean}
     * @memberof CreateWebhookEndpointRequest
     */
    'enabled'?: boolean;
}

export const CreateWebhookEndpointRequestEventsEnum = {
    VideoStarted: 'video.started',
    VideoFinished: 'video.finished',
    VideoFailed: 'video.failed'
} as const;

export type CreateWebhookEndpointRequestEventsEnum = typeof CreateWebhookEndpointRequestEventsEnum[keyof typeof CreateWebhookEndpointRequestEventsEnum];

/**
 * 
 * @export
 * @interface GeneratedAssets
 */
export interface GeneratedAssets {
    /**
     * The rendered video url.  
     * @type {string}
     * @memberof GeneratedAssets
     */
    'video_url'?: string;
    /**
     * Video creation timestamp.
     * @type {string}
     * @memberof GeneratedAssets
     */
    'created_date'?: string;
}
/**
 * 
 * @export
 * @interface Layer
 */
export interface Layer {
    [key: string]: any;

    /**
     * Name of the layer. This can be obtained from Layers section from the editor.
     * @type {string}
     * @memberof Layer
     */
    'name': string;
    /**
     * Sets the text to render on the layer.   ***Layer(s): Text, Machine code*** 
     * @type {string}
     * @memberof Layer
     */
    'text'?: string;
    /**
     * Refers to the boldness or thickness of the characters.  ***Layer(s): Text*** 
     * @type {number}
     * @memberof Layer
     */
    'weight'?: LayerWeightEnum;
    /**
     * The vertical distance between baselines of adjacent lines of text.  ***Layer(s): Text*** 
     * @type {number}
     * @memberof Layer
     */
    'line_height'?: number;
    /**
     * Refers to the adjustment of space between characters.  ***Layer(s): Text*** 
     * @type {number}
     * @memberof Layer
     */
    'tracking'?: number;
    /**
     * If set to `true`, the font size will be adjusted to fit the entire text inside the layer bounds.  ***Layer(s): Text*** 
     * @type {boolean}
     * @memberof Layer
     */
    'fit_text'?: boolean;
    /**
     * The size of the font. This will take effect if `fit_text` property is set to false.  ***Layer(s): Text, Chart*** 
     * @type {number}
     * @memberof Layer
     */
    'font_size'?: number;
    /**
     * Sets the horizontal alignment of the text inside layer bounds.  ***Layer(s): Text*** 
     * @type {string}
     * @memberof Layer
     */
    'align'?: LayerAlignEnum;
    /**
     * Styles the text with a italic face.  ***Layer(s): Text*** 
     * @type {boolean}
     * @memberof Layer
     */
    'italic'?: boolean;
    /**
     * If set to `true`, each line of text has a decorative line going through its middle.  ***Layer(s): Text*** 
     * @type {boolean}
     * @memberof Layer
     */
    'line_through'?: boolean;
    /**
     * If set to `true`, each line of text has a decorative line beneath it.  ***Layer(s): Text*** 
     * @type {boolean}
     * @memberof Layer
     */
    'underline'?: boolean;
    /**
     * If set to `true`, each line of text has a decorative line above it.  ***Layer(s): Text*** 
     * @type {boolean}
     * @memberof Layer
     */
    'overline'?: boolean;
    /**
     * Sets the color of the text on Text layer.  ***Layer(s): Text, Chart*** 
     * @type {string}
     * @memberof Layer
     */
    'text_color'?: string;
    /**
     * The text outline color.  ***Layer(s): Text*** 
     * @type {string}
     * @memberof Layer
     */
    'outline_color'?: string;
    /**
     * The width of the text outline.  ***Layer(s): Text*** 
     * @type {string}
     * @memberof Layer
     */
    'outline_width'?: LayerOutlineWidthEnum;
    /**
     * Adds shadows to text. It accepts a comma-separated list of shadows to be applied to the text. [Click here](https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow) for more detail.  ***Layer(s): Text*** 
     * @type {string}
     * @memberof Layer
     */
    'text_shadow'?: string;
    /**
     * The source image/video url that will be rendered on layer.  ***Layer(s): Image, Video*** 
     * @type {string}
     * @memberof Layer
     */
    'source_url'?: string;
    /**
     * Specifies the alignment of the image within the layer bounds. The value defines both the horizontal (left, center, right) and vertical (top, center, bottom) anchor points for positioning the image.  ***Layer(s): Image*** 
     * @type {string}
     * @memberof Layer
     */
    'position'?: LayerPositionEnum;
    /**
     * Controls how the image is displayed within layer bounds.  ***Layer(s): Image*** 
     * @type {string}
     * @memberof Layer
     */
    'image_size'?: LayerImageSizeEnum;
    /**
     * Flip the image vertically/horizontally/both.  ***Layer(s): Image*** 
     * @type {string}
     * @memberof Layer
     */
    'flip'?: LayerFlipEnum;
    /**
     * Applies selected graphical effect to the image.  ***Layer(s): Image*** 
     * @type {string}
     * @memberof Layer
     */
    'effect'?: LayerEffectEnum;
    /**
     * Sets the width of the layer\'s border.  ***Layer(s): Image, Machine code*** 
     * @type {number}
     * @memberof Layer
     */
    'border_width'?: number;
    /**
     * Rounds the corners of the layer\'s outer border edge.   ***Layer(s): Image, Machine code*** 
     * @type {number}
     * @memberof Layer
     */
    'border_radius'?: number;
    /**
     * Sets the color of the layer\'s border.  ***Layer(s): Image, Machine code*** 
     * @type {string}
     * @memberof Layer
     */
    'border_color'?: string;
    /**
     * Adds shadow effects around the layer. You can set multiple effects separated by commas. [Click here](https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow) for more detail.  ***Layer(s): Image*** 
     * @type {string}
     * @memberof Layer
     */
    'image_shadow'?: string;
    /**
     * Controls if the video\'s audio track will be mixed in the generated output or not.  ***Layer(s): Video*** 
     * @type {boolean}
     * @memberof Layer
     */
    'mute'?: boolean;
    /**
     * Controls whether the video will loop if the page\'s duration is greater than video\'s playtime.  ***Layer(s): Video*** 
     * @type {boolean}
     * @memberof Layer
     */
    'loop'?: boolean;
    /**
     * Sets the fill color of the shape, bar color on bar chart, line color on line chart, and partition color on pie chart.  ***Layer(s): Shape, Chart*** 
     * @type {string}
     * @memberof Layer
     */
    'fill_color'?: string;
    /**
     * Sets the stroke color of the shape.  ***Layer(s): Shape*** 
     * @type {string}
     * @memberof Layer
     */
    'stroke_color'?: string;
    /**
     * Sets the width of the stroke around the shape.  ***Layer(s): Shape*** 
     * @type {number}
     * @memberof Layer
     */
    'stroke_width'?: number;
    /**
     * The shape to be used at the corners of stroke.  ***Layer(s): Shape*** 
     * @type {string}
     * @memberof Layer
     */
    'stroke_corner'?: LayerStrokeCornerEnum;
    /**
     * Controls if the stoke around shape is dashed and in what proportion. 3:1 means 3 part stroke for 1 part space.  ***Layer(s): Shape*** 
     * @type {string}
     * @memberof Layer
     */
    'stroke_style'?: LayerStrokeStyleEnum;
    /**
     * Adds shadow effects around the layer. You can set multiple effects separated by commas. [Click here](https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function/drop-shadow) for more detail.  ***Layer(s): Shape*** 
     * @type {string}
     * @memberof Layer
     */
    'shape_shadow'?: string;
    /**
     * Sets the rating. The float values will rounded of to the nearest 0.5 eg: 1.2 => 1, 1.3 => 1.5.  ***Layer(s): Rating*** 
     * @type {number}
     * @memberof Layer
     */
    'rating'?: number;
    /**
     * Sets the active color of the rating.  ***Layer(s): Rating*** 
     * @type {string}
     * @memberof Layer
     */
    'active_fill_color'?: string;
    /**
     * Sets the inactive color of the rating.  ***Layer(s): Rating*** 
     * @type {string}
     * @memberof Layer
     */
    'inactive_fill_color'?: string;
    /**
     * Sets the fill color of the bar/QR code.  ***Layer(s): Machine code*** 
     * @type {string}
     * @memberof Layer
     */
    'foreground_color'?: string;
    /**
     * Sets the background color of the layer.  ***Layer(s): Machine code*** 
     * @type {string}
     * @memberof Layer
     */
    'background_color'?: string;
    /**
     * The data that will be used to generate the charts  ***Layer(s): Chart*** 
     * @type {Array<LayerChartDataInner>}
     * @memberof Layer
     */
    'chart_data'?: Array<LayerChartDataInner>;
    /**
     * Sets the color of: - The axes of bar/line chart. - The border of partion of pie chart.  ***Layer(s): Chart*** 
     * @type {string}
     * @memberof Layer
     */
    'axes_color'?: string;
}

export const LayerWeightEnum = {
    NUMBER_100: 100,
    NUMBER_200: 200,
    NUMBER_300: 300,
    NUMBER_400: 400,
    NUMBER_500: 500,
    NUMBER_600: 600,
    NUMBER_700: 700,
    NUMBER_800: 800,
    NUMBER_900: 900
} as const;

export type LayerWeightEnum = typeof LayerWeightEnum[keyof typeof LayerWeightEnum];
export const LayerAlignEnum = {
    Left: 'left',
    Center: 'center',
    Right: 'right'
} as const;

export type LayerAlignEnum = typeof LayerAlignEnum[keyof typeof LayerAlignEnum];
export const LayerOutlineWidthEnum = {
    None: 'none',
    Thin: 'thin',
    Medium: 'medium',
    Thick: 'thick'
} as const;

export type LayerOutlineWidthEnum = typeof LayerOutlineWidthEnum[keyof typeof LayerOutlineWidthEnum];
export const LayerPositionEnum = {
    LeftTop: 'left top',
    LeftBottom: 'left bottom',
    LeftCenter: 'left center',
    RightTop: 'right top',
    RightBottom: 'right bottom',
    RightCenter: 'right center',
    CenterTop: 'center top',
    CenterBottom: 'center bottom',
    CenterCenter: 'center center'
} as const;

export type LayerPositionEnum = typeof LayerPositionEnum[keyof typeof LayerPositionEnum];
export const LayerImageSizeEnum = {
    Auto: 'auto',
    Cover: 'cover',
    Contain: 'contain',
    ContainRepeat: 'contain repeat'
} as const;

export type LayerImageSizeEnum = typeof LayerImageSizeEnum[keyof typeof LayerImageSizeEnum];
export const LayerFlipEnum = {
    Vertical: 'vertical',
    Horizontal: 'horizontal',
    Both: 'both',
    Original: 'original'
} as const;

export type LayerFlipEnum = typeof LayerFlipEnum[keyof typeof LayerFlipEnum];
export const LayerEffectEnum = {
    Grayscale1: 'grayscale 1',
    Grayscale2: 'grayscale 2',
    Grayscale3: 'grayscale 3',
    Sepia1: 'sepia 1',
    Sepia2: 'sepia 2',
    Sepia3: 'sepia 3',
    Blur1: 'blur 1',
    Blur2: 'blur 2',
    Blur3: 'blur 3',
    Invert1: 'invert 1',
    Invert2: 'invert 2',
    Invert3: 'invert 3',
    Vintage1: 'vintage 1',
    Vintage2: 'vintage 2',
    Vintage3: 'vintage 3',
    Pixelate1: 'pixelate 1',
    Pixelate2: 'pixelate 2',
    Pixelate3: 'pixelate 3',
    Noise: 'noise',
    Squiggly: 'squiggly',
    GrayscaleBlur: 'grayscale blur',
    GrayscalePixelate: 'grayscale pixelate',
    SepiaBlur: 'sepia blur',
    SepiaPixelate: 'sepia pixelate',
    VintageBlur: 'vintage blur',
    VintagePixelate: 'vintage pixelate'
} as const;

export type LayerEffectEnum = typeof LayerEffectEnum[keyof typeof LayerEffectEnum];
export const LayerStrokeCornerEnum = {
    Round: 'round',
    Sharp: 'sharp'
} as const;

export type LayerStrokeCornerEnum = typeof LayerStrokeCornerEnum[keyof typeof LayerStrokeCornerEnum];
export const LayerStrokeStyleEnum = {
    None: 'none',
    _11: '1:1',
    _31: '3:1',
    _61: '6:1'
} as const;

export type LayerStrokeStyleEnum = typeof LayerStrokeStyleEnum[keyof typeof LayerStrokeStyleEnum];

/**
 * 
 * @export
 * @interface LayerChartDataInner
 */
export interface LayerChartDataInner {
    /**
     * This is label for:  - The X axis on bar/line chart. - The partition on pie chart. 
     * @type {string}
     * @memberof LayerChartDataInner
     */
    'label': string;
    /**
     * The value associated to the name. 
     * @type {number}
     * @memberof LayerChartDataInner
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface ListAllTemplates200Response
 */
export interface ListAllTemplates200Response {
    /**
     * 
     * @type {Array<ListAllTemplates200ResponseDataInner>}
     * @memberof ListAllTemplates200Response
     */
    'data'?: Array<ListAllTemplates200ResponseDataInner>;
    /**
     * 
     * @type {Pagination}
     * @memberof ListAllTemplates200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ListAllTemplates200ResponseDataInner
 */
export interface ListAllTemplates200ResponseDataInner {
    /**
     * The unique id of the template\'s
     * @type {string}
     * @memberof ListAllTemplates200ResponseDataInner
     */
    'id'?: string;
    /**
     * Template name
     * @type {string}
     * @memberof ListAllTemplates200ResponseDataInner
     */
    'name'?: string;
    /**
     * The template creation date
     * @type {string}
     * @memberof ListAllTemplates200ResponseDataInner
     */
    'created_at'?: string;
    /**
     * Last updated date of template
     * @type {string}
     * @memberof ListAllTemplates200ResponseDataInner
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ListAllVideos200Response
 */
export interface ListAllVideos200Response {
    /**
     * 
     * @type {Array<GeneratedAssets>}
     * @memberof ListAllVideos200Response
     */
    'data'?: Array<GeneratedAssets>;
    /**
     * 
     * @type {Pagination}
     * @memberof ListAllVideos200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ListWebhooks200Response
 */
export interface ListWebhooks200Response {
    /**
     * 
     * @type {Array<WebhookEndpoint>}
     * @memberof ListWebhooks200Response
     */
    'data'?: Array<WebhookEndpoint>;
    /**
     * 
     * @type {Pagination}
     * @memberof ListWebhooks200Response
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface NotFoundErrorResponse
 */
export interface NotFoundErrorResponse {
    /**
     * 
     * @type {NotFoundErrorResponseAllOfError}
     * @memberof NotFoundErrorResponse
     */
    'error': NotFoundErrorResponseAllOfError;
}
/**
 * 
 * @export
 * @interface NotFoundErrorResponseAllOfError
 */
export interface NotFoundErrorResponseAllOfError {
    /**
     * 
     * @type {string}
     * @memberof NotFoundErrorResponseAllOfError
     */
    'code'?: NotFoundErrorResponseAllOfErrorCodeEnum;
    /**
     * 
     * @type {any}
     * @memberof NotFoundErrorResponseAllOfError
     */
    'message'?: any;
}

export const NotFoundErrorResponseAllOfErrorCodeEnum = {
    ResourceNotFound: 'RESOURCE_NOT_FOUND',
    EndpointNotFound: 'ENDPOINT_NOT_FOUND'
} as const;

export type NotFoundErrorResponseAllOfErrorCodeEnum = typeof NotFoundErrorResponseAllOfErrorCodeEnum[keyof typeof NotFoundErrorResponseAllOfErrorCodeEnum];

/**
 * 
 * @export
 * @interface Page
 */
export interface Page {
    /**
     * The number of the page you want to make modifications to. 
     * @type {number}
     * @memberof Page
     */
    'number': number;
    /**
     * Sets the page\'s background color. It accepts any format of color or gradient.  `#3730a3`, `oklch(0.3984 0.1773 277.37)`, `radial-gradient(#e66465, blue)` are all valid values. 
     * @type {string}
     * @memberof Page
     */
    'background_color'?: string;
    /**
     * The source url of the audio that will play during the page animation in output video. 
     * @type {string}
     * @memberof Page
     */
    'page_audio_url'?: string;
    /**
     * #### Text layer propertires - text - weight - line_height - tracking - fit_text - font_size - align - italic - line_through - underline - overline - text_color - outline_color - outline_width - text_shadow #### Image layer properties - source_url - position - image_size - flip - effect - border_width - border_radius - border_color - image_shadow #### Video layer properties - source_url - mute - loop #### Shape layer properties - fill_color - stroke_color - stroke_width - stroke_corner - stroke_style - shape_shadow #### Rating layer properties - rating - active_fill_color - inactive_fill_color #### Machine code layer properties - text - foreground_color - background_color - border_width - border_radius - border_color #### Chart layer properties - chart_data - font_size - text_color - fill_color - axes_color 
     * @type {Array<Layer>}
     * @memberof Page
     */
    'layers'?: Array<Layer>;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'offset': number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'total': number;
    /**
     * 
     * @type {boolean}
     * @memberof Pagination
     */
    'has_more': boolean;
}
/**
 * 
 * @export
 * @interface PaymentRequiredErrorResponse
 */
export interface PaymentRequiredErrorResponse {
    /**
     * 
     * @type {PaymentRequiredErrorResponseAllOfError}
     * @memberof PaymentRequiredErrorResponse
     */
    'error': PaymentRequiredErrorResponseAllOfError;
}
/**
 * 
 * @export
 * @interface PaymentRequiredErrorResponseAllOfError
 */
export interface PaymentRequiredErrorResponseAllOfError {
    /**
     * 
     * @type {string}
     * @memberof PaymentRequiredErrorResponseAllOfError
     */
    'code'?: PaymentRequiredErrorResponseAllOfErrorCodeEnum;
    /**
     * 
     * @type {any}
     * @memberof PaymentRequiredErrorResponseAllOfError
     */
    'message'?: any;
}

export const PaymentRequiredErrorResponseAllOfErrorCodeEnum = {
    PaymentRequired: 'PAYMENT_REQUIRED',
    InsufficientCredits: 'INSUFFICIENT_CREDITS',
    SubscriptionExpired: 'SUBSCRIPTION_EXPIRED'
} as const;

export type PaymentRequiredErrorResponseAllOfErrorCodeEnum = typeof PaymentRequiredErrorResponseAllOfErrorCodeEnum[keyof typeof PaymentRequiredErrorResponseAllOfErrorCodeEnum];

/**
 * 
 * @export
 * @interface RateLimitErrorResponse
 */
export interface RateLimitErrorResponse {
    /**
     * 
     * @type {RateLimitErrorResponseAllOfError}
     * @memberof RateLimitErrorResponse
     */
    'error': RateLimitErrorResponseAllOfError;
}
/**
 * 
 * @export
 * @interface RateLimitErrorResponseAllOfError
 */
export interface RateLimitErrorResponseAllOfError {
    /**
     * 
     * @type {string}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'code'?: RateLimitErrorResponseAllOfErrorCodeEnum;
    /**
     * 
     * @type {any}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'message'?: any;
    /**
     * Number of seconds to wait before retrying
     * @type {number}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'retry_after'?: number;
    /**
     * The rate limit ceiling for this request
     * @type {number}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'limit'?: number;
    /**
     * Number of requests remaining in current time window
     * @type {number}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'remaining'?: number;
    /**
     * Unix timestamp when the rate limit resets
     * @type {number}
     * @memberof RateLimitErrorResponseAllOfError
     */
    'reset'?: number;
}

export const RateLimitErrorResponseAllOfErrorCodeEnum = {
    RateLimitExceeded: 'RATE_LIMIT_EXCEEDED',
    TooManyRequests: 'TOO_MANY_REQUESTS'
} as const;

export type RateLimitErrorResponseAllOfErrorCodeEnum = typeof RateLimitErrorResponseAllOfErrorCodeEnum[keyof typeof RateLimitErrorResponseAllOfErrorCodeEnum];

/**
 * 
 * @export
 * @interface ServerErrorResponse
 */
export interface ServerErrorResponse {
    /**
     * 
     * @type {ServerErrorResponseAllOfError}
     * @memberof ServerErrorResponse
     */
    'error': ServerErrorResponseAllOfError;
}
/**
 * 
 * @export
 * @interface ServerErrorResponseAllOfError
 */
export interface ServerErrorResponseAllOfError {
    /**
     * 
     * @type {string}
     * @memberof ServerErrorResponseAllOfError
     */
    'code'?: ServerErrorResponseAllOfErrorCodeEnum;
    /**
     * 
     * @type {any}
     * @memberof ServerErrorResponseAllOfError
     */
    'message'?: any;
}

export const ServerErrorResponseAllOfErrorCodeEnum = {
    InternalServerError: 'INTERNAL_SERVER_ERROR',
    ProcessingError: 'PROCESSING_ERROR',
    DatabaseError: 'DATABASE_ERROR'
} as const;

export type ServerErrorResponseAllOfErrorCodeEnum = typeof ServerErrorResponseAllOfErrorCodeEnum[keyof typeof ServerErrorResponseAllOfErrorCodeEnum];

/**
 * 
 * @export
 * @interface ServiceUnavailableErrorResponse
 */
export interface ServiceUnavailableErrorResponse {
    /**
     * 
     * @type {ServiceUnavailableErrorResponseAllOfError}
     * @memberof ServiceUnavailableErrorResponse
     */
    'error': ServiceUnavailableErrorResponseAllOfError;
}
/**
 * 
 * @export
 * @interface ServiceUnavailableErrorResponseAllOfError
 */
export interface ServiceUnavailableErrorResponseAllOfError {
    /**
     * 
     * @type {string}
     * @memberof ServiceUnavailableErrorResponseAllOfError
     */
    'code'?: ServiceUnavailableErrorResponseAllOfErrorCodeEnum;
    /**
     * 
     * @type {any}
     * @memberof ServiceUnavailableErrorResponseAllOfError
     */
    'message'?: any;
    /**
     * Number of seconds to wait before retrying
     * @type {number}
     * @memberof ServiceUnavailableErrorResponseAllOfError
     */
    'retry_after'?: number;
}

export const ServiceUnavailableErrorResponseAllOfErrorCodeEnum = {
    ServiceUnavailable: 'SERVICE_UNAVAILABLE',
    MaintenanceMode: 'MAINTENANCE_MODE',
    Overloaded: 'OVERLOADED'
} as const;

export type ServiceUnavailableErrorResponseAllOfErrorCodeEnum = typeof ServiceUnavailableErrorResponseAllOfErrorCodeEnum[keyof typeof ServiceUnavailableErrorResponseAllOfErrorCodeEnum];

/**
 * 
 * @export
 * @interface StandardErrorResponse
 */
export interface StandardErrorResponse {
    /**
     * 
     * @type {StandardErrorResponseError}
     * @memberof StandardErrorResponse
     */
    'error': StandardErrorResponseError;
}
/**
 * 
 * @export
 * @interface StandardErrorResponseError
 */
export interface StandardErrorResponseError {
    /**
     * Error code identifying the type of error
     * @type {string}
     * @memberof StandardErrorResponseError
     */
    'code': string;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof StandardErrorResponseError
     */
    'message': string;
    /**
     * Additional error details (optional)
     * @type {string}
     * @memberof StandardErrorResponseError
     */
    'details'?: string;
}
/**
 * 
 * @export
 * @interface UpdateWebhookEndpointRequest
 */
export interface UpdateWebhookEndpointRequest {
    /**
     * The URL to send webhook notifications to
     * @type {string}
     * @memberof UpdateWebhookEndpointRequest
     */
    'url'?: string;
    /**
     * List of events to subscribe to: `\"video.started\"`, `\"video.finished\"`, `\"video.failed\"` 
     * @type {Array<string>}
     * @memberof UpdateWebhookEndpointRequest
     */
    'events'?: Array<UpdateWebhookEndpointRequestEventsEnum>;
    /**
     * Whether the webhook is enabled
     * @type {boolean}
     * @memberof UpdateWebhookEndpointRequest
     */
    'enabled'?: boolean;
}

export const UpdateWebhookEndpointRequestEventsEnum = {
    VideoStarted: 'video.started',
    VideoFinished: 'video.finished',
    VideoFailed: 'video.failed'
} as const;

export type UpdateWebhookEndpointRequestEventsEnum = typeof UpdateWebhookEndpointRequestEventsEnum[keyof typeof UpdateWebhookEndpointRequestEventsEnum];

/**
 * 
 * @export
 * @interface ValidationErrorDetail
 */
export interface ValidationErrorDetail {
    /**
     * The field that failed validation
     * @type {string}
     * @memberof ValidationErrorDetail
     */
    'field': string;
    /**
     * Specific error code for the validation failure
     * @type {string}
     * @memberof ValidationErrorDetail
     */
    'code': ValidationErrorDetailCodeEnum;
    /**
     * Human-readable error message
     * @type {string}
     * @memberof ValidationErrorDetail
     */
    'message': string;
    /**
     * 
     * @type {any}
     * @memberof ValidationErrorDetail
     */
    'value'?: any;
}

export const ValidationErrorDetailCodeEnum = {
    RequiredField: 'REQUIRED_FIELD',
    InvalidValue: 'INVALID_VALUE',
    InvalidType: 'INVALID_TYPE',
    InvalidFormat: 'INVALID_FORMAT',
    ValueTooSmall: 'VALUE_TOO_SMALL',
    ValueTooLarge: 'VALUE_TOO_LARGE',
    ValidationError: 'VALIDATION_ERROR'
} as const;

export type ValidationErrorDetailCodeEnum = typeof ValidationErrorDetailCodeEnum[keyof typeof ValidationErrorDetailCodeEnum];

/**
 * 
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
    /**
     * 
     * @type {ValidationErrorResponseError}
     * @memberof ValidationErrorResponse
     */
    'error': ValidationErrorResponseError;
}
/**
 * 
 * @export
 * @interface ValidationErrorResponseError
 */
export interface ValidationErrorResponseError {
    /**
     * Error code for validation failures
     * @type {string}
     * @memberof ValidationErrorResponseError
     */
    'code': ValidationErrorResponseErrorCodeEnum;
    /**
     * High-level error message
     * @type {string}
     * @memberof ValidationErrorResponseError
     */
    'message': string;
    /**
     * Detailed validation errors for each field
     * @type {Array<ValidationErrorDetail>}
     * @memberof ValidationErrorResponseError
     */
    'details'?: Array<ValidationErrorDetail>;
}

export const ValidationErrorResponseErrorCodeEnum = {
    ValidationError: 'VALIDATION_ERROR'
} as const;

export type ValidationErrorResponseErrorCodeEnum = typeof ValidationErrorResponseErrorCodeEnum[keyof typeof ValidationErrorResponseErrorCodeEnum];

/**
 * 
 * @export
 * @interface Video
 */
export interface Video {
    /**
     * The status of the video generation request. 
     * @type {string}
     * @memberof Video
     */
    'status'?: VideoStatusEnum;
    /**
     * Unique id for the video generation request. 
     * @type {string}
     * @memberof Video
     */
    'id'?: string;
    /**
     * The url the video generation request.  
     * @type {string}
     * @memberof Video
     */
    'self'?: string;
    /**
     * The rendered video url.  This populates when the video has the status `COMPLETED`. 
     * @type {string}
     * @memberof Video
     */
    'video_url'?: string;
    /**
     * The metadata passed to the video generation initiation request. 
     * @type {string}
     * @memberof Video
     */
    'metadata'?: string;
    /**
     * Video genration request creation timestamp.
     * @type {string}
     * @memberof Video
     */
    'created_at'?: string;
    /**
     * Last updated timestamp of video genration request.
     * @type {string}
     * @memberof Video
     */
    'updated_at'?: string;
}

export const VideoStatusEnum = {
    Queued: 'QUEUED',
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type VideoStatusEnum = typeof VideoStatusEnum[keyof typeof VideoStatusEnum];

/**
 * 
 * @export
 * @interface WebhookEndpoint
 */
export interface WebhookEndpoint {
    /**
     * 
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookEndpoint
     */
    'events': Array<WebhookEndpointEventsEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookEndpoint
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEndpoint
     */
    'updated_at': string;
}

export const WebhookEndpointEventsEnum = {
    VideoStarted: 'video.started',
    VideoFinished: 'video.finished',
    VideoFailed: 'video.failed'
} as const;

export type WebhookEndpointEventsEnum = typeof WebhookEndpointEventsEnum[keyof typeof WebhookEndpointEventsEnum];

/**
 * 
 * @export
 * @interface WebhookEndpointCreate
 */
export interface WebhookEndpointCreate {
    /**
     * Unique identifier of the webhook endpoint. 
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'id': string;
    /**
     * Keep this secret safe and do not share it. You won\'t be able to retrieve it again. 
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'secret': string;
    /**
     * Organization identifier associated to the webhook endpoint 
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'org_id': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'url': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebhookEndpointCreate
     */
    'events': Array<WebhookEndpointCreateEventsEnum>;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookEndpointCreate
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof WebhookEndpointCreate
     */
    'updated_at': string;
}

export const WebhookEndpointCreateEventsEnum = {
    VideoStarted: 'video.started',
    VideoFinished: 'video.finished',
    VideoFailed: 'video.failed'
} as const;

export type WebhookEndpointCreateEventsEnum = typeof WebhookEndpointCreateEventsEnum[keyof typeof WebhookEndpointCreateEventsEnum];


/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all template\'s
         * @param {string} [id] Maximum number of results to return.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTemplates: async (id?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all template\'s
         * @param {string} [id] Maximum number of results to return.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTemplates(id?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllTemplates200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTemplates(id, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TemplatesApi.listAllTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * List all template\'s
         * @param {string} [id] Maximum number of results to return.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTemplates(id?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAllTemplates200Response> {
            return localVarFp.listAllTemplates(id, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * List all template\'s
     * @param {string} [id] Maximum number of results to return.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public listAllTemplates(id?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).listAllTemplates(id, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VideosApi - axios parameter creator
 * @export
 */
export const VideosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a new video. Check the parameters for details.
         * @summary Create New Video
         * @param {CreateVideosRequest} createVideosRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideos: async (createVideosRequest: CreateVideosRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createVideosRequest' is not null or undefined
            assertParamExists('createVideos', 'createVideosRequest', createVideosRequest)
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVideosRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Endpoint to check the status of the video generation request
         * @param {string} id Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVideoStatus', 'id', id)
            const localVarPath = `/videos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all completed past video generation.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllVideos: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/videos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VideosApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a new video. Check the parameters for details.
         * @summary Create New Video
         * @param {CreateVideosRequest} createVideosRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVideos(createVideosRequest: CreateVideosRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVideos(createVideosRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideosApi.createVideos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Endpoint to check the status of the video generation request
         * @param {string} id Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVideoStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Video>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVideoStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideosApi.getVideoStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all completed past video generation.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllVideos(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListAllVideos200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllVideos(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VideosApi.listAllVideos']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VideosApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a new video. Check the parameters for details.
         * @summary Create New Video
         * @param {CreateVideosRequest} createVideosRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVideos(createVideosRequest: CreateVideosRequest, options?: RawAxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.createVideos(createVideosRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint to check the status of the video generation request
         * @param {string} id Request Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVideoStatus(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Video> {
            return localVarFp.getVideoStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all completed past video generation.
         * @param {number} [limit] Maximum number of results to return.
         * @param {number} [offset] Number of results to skip.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllVideos(limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<ListAllVideos200Response> {
            return localVarFp.listAllVideos(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI {
    /**
     * Use this endpoint to create a new video. Check the parameters for details.
     * @summary Create New Video
     * @param {CreateVideosRequest} createVideosRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public createVideos(createVideosRequest: CreateVideosRequest, options?: RawAxiosRequestConfig) {
        return VideosApiFp(this.configuration).createVideos(createVideosRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Endpoint to check the status of the video generation request
     * @param {string} id Request Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public getVideoStatus(id: string, options?: RawAxiosRequestConfig) {
        return VideosApiFp(this.configuration).getVideoStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all completed past video generation.
     * @param {number} [limit] Maximum number of results to return.
     * @param {number} [offset] Number of results to skip.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VideosApi
     */
    public listAllVideos(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return VideosApiFp(this.configuration).listAllVideos(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new webhook endpoint for the authenticated organization
         * @summary Create webhook
         * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: async (createWebhookEndpointRequest: CreateWebhookEndpointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWebhookEndpointRequest' is not null or undefined
            assertParamExists('createWebhook', 'createWebhookEndpointRequest', createWebhookEndpointRequest)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWebhookEndpointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a webhook endpoint by ID
         * @summary Delete webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('deleteWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific webhook endpoint by ID
         * @summary Get webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: async (webhookId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('getWebhook', 'webhookId', webhookId)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all webhook endpoints for the authenticated organization
         * @summary List webhooks
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Number of results to skip
         * @param {boolean} [enabled] Filter by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks: async (limit?: number, offset?: number, enabled?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing webhook endpoint
         * @summary Update webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook: async (webhookId: string, updateWebhookEndpointRequest: UpdateWebhookEndpointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookId' is not null or undefined
            assertParamExists('updateWebhook', 'webhookId', webhookId)
            // verify required parameter 'updateWebhookEndpointRequest' is not null or undefined
            assertParamExists('updateWebhook', 'updateWebhookEndpointRequest', updateWebhookEndpointRequest)
            const localVarPath = `/webhooks/{webhook_id}`
                .replace(`{${"webhook_id"}}`, encodeURIComponent(String(webhookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerHttpAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWebhookEndpointRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new webhook endpoint for the authenticated organization
         * @summary Create webhook
         * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWebhook(createWebhookEndpointRequest: CreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpointCreate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookEndpointRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a webhook endpoint by ID
         * @summary Delete webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific webhook endpoint by ID
         * @summary Get webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhook(webhookId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhook(webhookId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all webhook endpoints for the authenticated organization
         * @summary List webhooks
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Number of results to skip
         * @param {boolean} [enabled] Filter by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebhooks(limit?: number, offset?: number, enabled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWebhooks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, offset, enabled, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing webhook endpoint
         * @summary Update webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWebhook(webhookId: string, updateWebhookEndpointRequest: UpdateWebhookEndpointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookEndpointRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Create a new webhook endpoint for the authenticated organization
         * @summary Create webhook
         * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(createWebhookEndpointRequest: CreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEndpointCreate> {
            return localVarFp.createWebhook(createWebhookEndpointRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a webhook endpoint by ID
         * @summary Delete webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific webhook endpoint by ID
         * @summary Get webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEndpoint> {
            return localVarFp.getWebhook(webhookId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all webhook endpoints for the authenticated organization
         * @summary List webhooks
         * @param {number} [limit] Maximum number of results to return
         * @param {number} [offset] Number of results to skip
         * @param {boolean} [enabled] Filter by enabled status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebhooks(limit?: number, offset?: number, enabled?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ListWebhooks200Response> {
            return localVarFp.listWebhooks(limit, offset, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing webhook endpoint
         * @summary Update webhook
         * @param {string} webhookId Webhook endpoint ID
         * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, updateWebhookEndpointRequest: UpdateWebhookEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEndpoint> {
            return localVarFp.updateWebhook(webhookId, updateWebhookEndpointRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Create a new webhook endpoint for the authenticated organization
     * @summary Create webhook
     * @param {CreateWebhookEndpointRequest} createWebhookEndpointRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public createWebhook(createWebhookEndpointRequest: CreateWebhookEndpointRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).createWebhook(createWebhookEndpointRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a webhook endpoint by ID
     * @summary Delete webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public deleteWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific webhook endpoint by ID
     * @summary Get webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public getWebhook(webhookId: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all webhook endpoints for the authenticated organization
     * @summary List webhooks
     * @param {number} [limit] Maximum number of results to return
     * @param {number} [offset] Number of results to skip
     * @param {boolean} [enabled] Filter by enabled status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public listWebhooks(limit?: number, offset?: number, enabled?: boolean, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).listWebhooks(limit, offset, enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing webhook endpoint
     * @summary Update webhook
     * @param {string} webhookId Webhook endpoint ID
     * @param {UpdateWebhookEndpointRequest} updateWebhookEndpointRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public updateWebhook(webhookId: string, updateWebhookEndpointRequest: UpdateWebhookEndpointRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).updateWebhook(webhookId, updateWebhookEndpointRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



